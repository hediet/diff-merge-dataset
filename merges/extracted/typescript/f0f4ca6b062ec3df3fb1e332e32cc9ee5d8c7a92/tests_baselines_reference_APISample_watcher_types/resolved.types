=== tests/cases/compiler/APISample_watcher.ts ===

/*
 * Note: This test is a public API sample. The sample sources can be found 
         at: https://github.com/Microsoft/TypeScript/wiki/Using-the-Compiler-API#incremental-build-support-using-the-language-services
 *       Please log a "breaking change" issue for any API breaking change affecting this issue
 */

declare var process: any;
>process : any

declare var console: any;
>console : any

declare var fs: any;
>fs : any

declare var path: any;
>path : any

import ts = require("typescript");
>ts : typeof ts

function watch(rootFileNames: string[], options: ts.CompilerOptions) {
>watch : (rootFileNames: string[], options: ts.CompilerOptions) => void
>rootFileNames : string[]
>options : ts.CompilerOptions
>ts : unknown
>CompilerOptions : ts.CompilerOptions

    var files: ts.Map<{ version: number }> = {};
>files : ts.Map<{ version: number; }>
>ts : unknown
>Map : ts.Map<T>
>version : number
>{} : { [x: string]: undefined; }

    // initialize the list of files
    rootFileNames.forEach(fileName => {
>rootFileNames.forEach(fileName => {        files[fileName] = { version: 0 };    }) : void
>rootFileNames.forEach : (callbackfn: (value: string, index: number, array: string[]) => void, thisArg?: any) => void
>rootFileNames : string[]
>forEach : (callbackfn: (value: string, index: number, array: string[]) => void, thisArg?: any) => void
>fileName => {        files[fileName] = { version: 0 };    } : (fileName: string) => void
>fileName : string

        files[fileName] = { version: 0 };
>files[fileName] = { version: 0 } : { version: number; }
>files[fileName] : { version: number; }
>files : ts.Map<{ version: number; }>
>fileName : string
>{ version: 0 } : { version: number; }
>version : number

    });

    // Create the language service host to allow the LS to communicate with the host
    var servicesHost: ts.LanguageServiceHost = {
>servicesHost : ts.LanguageServiceHost
>ts : unknown
>LanguageServiceHost : ts.LanguageServiceHost
>{        getScriptFileNames: () => rootFileNames,        getScriptVersion: (fileName) => files[fileName] && files[fileName].version.toString(),        getScriptSnapshot: (fileName) => {            if (!fs.existsSync(fileName)) {                return undefined;            }            return ts.ScriptSnapshot.fromString(fs.readFileSync(fileName).toString());        },        getCurrentDirectory: () => process.cwd(),        getCompilationSettings: () => options,        getDefaultLibFileName: (options) => ts.getDefaultLibFilePath(options),    } : { getScriptFileNames: () => string[]; getScriptVersion: (fileName: string) => string; getScriptSnapshot: (fileName: string) => ts.IScriptSnapshot; getCurrentDirectory: () => any; getCompilationSettings: () => ts.CompilerOptions; getDefaultLibFileName: (options: ts.CompilerOptions) => string; }

        getScriptFileNames: () => rootFileNames,
>getScriptFileNames : () => string[]
>() => rootFileNames : () => string[]
>rootFileNames : string[]

        getScriptVersion: (fileName) => files[fileName] && files[fileName].version.toString(),
>getScriptVersion : (fileName: string) => string
>(fileName) => files[fileName] && files[fileName].version.toString() : (fileName: string) => string
>fileName : string
>files[fileName] && files[fileName].version.toString() : string
>files[fileName] : { version: number; }
>files : ts.Map<{ version: number; }>
>fileName : string
>files[fileName].version.toString() : string
>files[fileName].version.toString : (radix?: number) => string
>files[fileName].version : number
>files[fileName] : { version: number; }
>files : ts.Map<{ version: number; }>
>fileName : string
>version : number
>toString : (radix?: number) => string

        getScriptSnapshot: (fileName) => {
>getScriptSnapshot : (fileName: string) => ts.IScriptSnapshot
>(fileName) => {            if (!fs.existsSync(fileName)) {                return undefined;            }            return ts.ScriptSnapshot.fromString(fs.readFileSync(fileName).toString());        } : (fileName: string) => ts.IScriptSnapshot
>fileName : string

            if (!fs.existsSync(fileName)) {
>!fs.existsSync(fileName) : boolean
>fs.existsSync(fileName) : any
>fs.existsSync : any
>fs : any
>existsSync : any
>fileName : string

                return undefined;
>undefined : undefined
            }

            return ts.ScriptSnapshot.fromString(fs.readFileSync(fileName).toString());
>ts.ScriptSnapshot.fromString(fs.readFileSync(fileName).toString()) : ts.IScriptSnapshot
>ts.ScriptSnapshot.fromString : (text: string) => ts.IScriptSnapshot
>ts.ScriptSnapshot : typeof ts.ScriptSnapshot
>ts : typeof ts
>ScriptSnapshot : typeof ts.ScriptSnapshot
>fromString : (text: string) => ts.IScriptSnapshot
>fs.readFileSync(fileName).toString() : any
>fs.readFileSync(fileName).toString : any
>fs.readFileSync(fileName) : any
>fs.readFileSync : any
>fs : any
>readFileSync : any
>fileName : string
>toString : any

        },
        getCurrentDirectory: () => process.cwd(),
>getCurrentDirectory : () => any
>() => process.cwd() : () => any
>process.cwd() : any
>process.cwd : any
>process : any
>cwd : any

        getCompilationSettings: () => options,
>getCompilationSettings : () => ts.CompilerOptions
>() => options : () => ts.CompilerOptions
>options : ts.CompilerOptions

        getDefaultLibFileName: (options) => ts.getDefaultLibFilePath(options),
>getDefaultLibFileName : (options: ts.CompilerOptions) => string
>(options) => ts.getDefaultLibFilePath(options) : (options: ts.CompilerOptions) => string
>options : ts.CompilerOptions
>ts.getDefaultLibFilePath(options) : string
>ts.getDefaultLibFilePath : (options: ts.CompilerOptions) => string
>ts : typeof ts
>getDefaultLibFilePath : (options: ts.CompilerOptions) => string
>options : ts.CompilerOptions

    };

    // Create the language service files
    var services = ts.createLanguageService(servicesHost, ts.createDocumentRegistry())
>services : ts.LanguageService
>ts.createLanguageService(servicesHost, ts.createDocumentRegistry()) : ts.LanguageService
>ts.createLanguageService : (host: ts.LanguageServiceHost, documentRegistry?: ts.DocumentRegistry) => ts.LanguageService
>ts : typeof ts
>createLanguageService : (host: ts.LanguageServiceHost, documentRegistry?: ts.DocumentRegistry) => ts.LanguageService
>servicesHost : ts.LanguageServiceHost
>ts.createDocumentRegistry() : ts.DocumentRegistry
>ts.createDocumentRegistry : () => ts.DocumentRegistry
>ts : typeof ts
>createDocumentRegistry : () => ts.DocumentRegistry

    // Now let's watch the files
    rootFileNames.forEach(fileName => {
>rootFileNames.forEach(fileName => {        // First time around, emit all files        emitFile(fileName);        // Add a watch on the file to handle next change        fs.watchFile(fileName,            { persistent: true, interval: 250 },            (curr, prev) => {                // Check timestamp                if (+curr.mtime <= +prev.mtime) {                    return;                }                // Update the version to signal a change in the file                files[fileName].version++;                // write the changes to disk                emitFile(fileName);            });    }) : void
>rootFileNames.forEach : (callbackfn: (value: string, index: number, array: string[]) => void, thisArg?: any) => void
>rootFileNames : string[]
>forEach : (callbackfn: (value: string, index: number, array: string[]) => void, thisArg?: any) => void
>fileName => {        // First time around, emit all files        emitFile(fileName);        // Add a watch on the file to handle next change        fs.watchFile(fileName,            { persistent: true, interval: 250 },            (curr, prev) => {                // Check timestamp                if (+curr.mtime <= +prev.mtime) {                    return;                }                // Update the version to signal a change in the file                files[fileName].version++;                // write the changes to disk                emitFile(fileName);            });    } : (fileName: string) => void
>fileName : string

        // First time around, emit all files
        emitFile(fileName);
>emitFile(fileName) : void
>emitFile : (fileName: string) => void
>fileName : string

        // Add a watch on the file to handle next change
        fs.watchFile(fileName,
>fs.watchFile(fileName,            { persistent: true, interval: 250 },            (curr, prev) => {                // Check timestamp                if (+curr.mtime <= +prev.mtime) {                    return;                }                // Update the version to signal a change in the file                files[fileName].version++;                // write the changes to disk                emitFile(fileName);            }) : any
>fs.watchFile : any
>fs : any
>watchFile : any
>fileName : string

            { persistent: true, interval: 250 },
>{ persistent: true, interval: 250 } : { persistent: boolean; interval: number; }
>persistent : boolean
>interval : number

            (curr, prev) => {
>(curr, prev) => {                // Check timestamp                if (+curr.mtime <= +prev.mtime) {                    return;                }                // Update the version to signal a change in the file                files[fileName].version++;                // write the changes to disk                emitFile(fileName);            } : (curr: any, prev: any) => void
>curr : any
>prev : any

                // Check timestamp
                if (+curr.mtime <= +prev.mtime) {
>+curr.mtime <= +prev.mtime : boolean
>+curr.mtime : number
>curr.mtime : any
>curr : any
>mtime : any
>+prev.mtime : number
>prev.mtime : any
>prev : any
>mtime : any

                    return;
                }

                // Update the version to signal a change in the file
                files[fileName].version++;
>files[fileName].version++ : number
>files[fileName].version : number
>files[fileName] : { version: number; }
>files : ts.Map<{ version: number; }>
>fileName : string
>version : number

                // write the changes to disk
                emitFile(fileName);
>emitFile(fileName) : void
>emitFile : (fileName: string) => void
>fileName : string

            });
    });

    function emitFile(fileName: string) {
>emitFile : (fileName: string) => void
>fileName : string

        var output = services.getEmitOutput(fileName);
>output : ts.EmitOutput
>services.getEmitOutput(fileName) : ts.EmitOutput
>services.getEmitOutput : (fileName: string) => ts.EmitOutput
>services : ts.LanguageService
>getEmitOutput : (fileName: string) => ts.EmitOutput
>fileName : string

        if (!output.emitSkipped) {
>!output.emitSkipped : boolean
>output.emitSkipped : boolean
>output : ts.EmitOutput
>emitSkipped : boolean

            console.log(`Emitting ${fileName}`);
>console.log(`Emitting ${fileName}`) : any
>console.log : any
>console : any
>log : any
>fileName : string
        }
        else {
            console.log(`Emitting ${fileName} failed`);
>console.log(`Emitting ${fileName} failed`) : any
>console.log : any
>console : any
>log : any
>fileName : string

            logErrors(fileName);
>logErrors(fileName) : void
>logErrors : (fileName: string) => void
>fileName : string
        }

        output.outputFiles.forEach(o => {
>output.outputFiles.forEach(o => {            fs.writeFileSync(o.name, o.text, "utf8");        }) : void
>output.outputFiles.forEach : (callbackfn: (value: ts.OutputFile, index: number, array: ts.OutputFile[]) => void, thisArg?: any) => void
>output.outputFiles : ts.OutputFile[]
>output : ts.EmitOutput
>outputFiles : ts.OutputFile[]
>forEach : (callbackfn: (value: ts.OutputFile, index: number, array: ts.OutputFile[]) => void, thisArg?: any) => void
>o => {            fs.writeFileSync(o.name, o.text, "utf8");        } : (o: ts.OutputFile) => void
>o : ts.OutputFile

            fs.writeFileSync(o.name, o.text, "utf8");
>fs.writeFileSync(o.name, o.text, "utf8") : any
>fs.writeFileSync : any
>fs : any
>writeFileSync : any
>o.name : string
>o : ts.OutputFile
>name : string
>o.text : string
>o : ts.OutputFile
>text : string

        });
    }

    function logErrors(fileName: string) {
>logErrors : (fileName: string) => void
>fileName : string

        var allDiagnostics = services.getCompilerOptionsDiagnostics()
>allDiagnostics : ts.Diagnostic[]
>services.getCompilerOptionsDiagnostics()            .concat(services.getSyntacticDiagnostics(fileName))            .concat(services.getSemanticDiagnostics(fileName)) : ts.Diagnostic[]
>services.getCompilerOptionsDiagnostics()            .concat(services.getSyntacticDiagnostics(fileName))            .concat : { <U extends ts.Diagnostic[]>(...items: U[]): ts.Diagnostic[]; (...items: ts.Diagnostic[]): ts.Diagnostic[]; }
>services.getCompilerOptionsDiagnostics()            .concat(services.getSyntacticDiagnostics(fileName)) : ts.Diagnostic[]
>services.getCompilerOptionsDiagnostics()            .concat : { <U extends ts.Diagnostic[]>(...items: U[]): ts.Diagnostic[]; (...items: ts.Diagnostic[]): ts.Diagnostic[]; }
>services.getCompilerOptionsDiagnostics() : ts.Diagnostic[]
>services.getCompilerOptionsDiagnostics : () => ts.Diagnostic[]
>services : ts.LanguageService
>getCompilerOptionsDiagnostics : () => ts.Diagnostic[]

            .concat(services.getSyntacticDiagnostics(fileName))
>concat : { <U extends ts.Diagnostic[]>(...items: U[]): ts.Diagnostic[]; (...items: ts.Diagnostic[]): ts.Diagnostic[]; }
>services.getSyntacticDiagnostics(fileName) : ts.Diagnostic[]
>services.getSyntacticDiagnostics : (fileName: string) => ts.Diagnostic[]
>services : ts.LanguageService
>getSyntacticDiagnostics : (fileName: string) => ts.Diagnostic[]
>fileName : string

            .concat(services.getSemanticDiagnostics(fileName));
>concat : { <U extends ts.Diagnostic[]>(...items: U[]): ts.Diagnostic[]; (...items: ts.Diagnostic[]): ts.Diagnostic[]; }
>services.getSemanticDiagnostics(fileName) : ts.Diagnostic[]
>services.getSemanticDiagnostics : (fileName: string) => ts.Diagnostic[]
>services : ts.LanguageService
>getSemanticDiagnostics : (fileName: string) => ts.Diagnostic[]
>fileName : string

        allDiagnostics.forEach(diagnostic => {
>allDiagnostics.forEach(diagnostic => {            if (diagnostic.file) {                var lineChar = diagnostic.file.getLineAndCharacterOfPosition(diagnostic.start);                console.log(`  Error ${diagnostic.file.fileName} (${lineChar.line + 1},${lineChar.character + 1}): ${ts.flattenDiagnosticMessageText(diagnostic.messageText, "\n")}`);            }            else {                console.log(`  Error: ${diagnostic.messageText}`);            }        }) : void
>allDiagnostics.forEach : (callbackfn: (value: ts.Diagnostic, index: number, array: ts.Diagnostic[]) => void, thisArg?: any) => void
>allDiagnostics : ts.Diagnostic[]
>forEach : (callbackfn: (value: ts.Diagnostic, index: number, array: ts.Diagnostic[]) => void, thisArg?: any) => void
>diagnostic => {            if (diagnostic.file) {                var lineChar = diagnostic.file.getLineAndCharacterOfPosition(diagnostic.start);                console.log(`  Error ${diagnostic.file.fileName} (${lineChar.line + 1},${lineChar.character + 1}): ${ts.flattenDiagnosticMessageText(diagnostic.messageText, "\n")}`);            }            else {                console.log(`  Error: ${diagnostic.messageText}`);            }        } : (diagnostic: ts.Diagnostic) => void
>diagnostic : ts.Diagnostic

            if (diagnostic.file) {
>diagnostic.file : ts.SourceFile
>diagnostic : ts.Diagnostic
>file : ts.SourceFile

                var lineChar = diagnostic.file.getLineAndCharacterOfPosition(diagnostic.start);
>lineChar : ts.LineAndCharacter
>diagnostic.file.getLineAndCharacterOfPosition(diagnostic.start) : ts.LineAndCharacter
>diagnostic.file.getLineAndCharacterOfPosition : (pos: number) => ts.LineAndCharacter
>diagnostic.file : ts.SourceFile
>diagnostic : ts.Diagnostic
>file : ts.SourceFile
>getLineAndCharacterOfPosition : (pos: number) => ts.LineAndCharacter
>diagnostic.start : number
>diagnostic : ts.Diagnostic
>start : number

                console.log(`  Error ${diagnostic.file.fileName} (${lineChar.line + 1},${lineChar.character + 1}): ${ts.flattenDiagnosticMessageText(diagnostic.messageText, "\n")}`);
>console.log(`  Error ${diagnostic.file.fileName} (${lineChar.line + 1},${lineChar.character + 1}): ${ts.flattenDiagnosticMessageText(diagnostic.messageText, "\n")}`) : any
>console.log : any
>console : any
>log : any
>diagnostic.file.fileName : string
>diagnostic.file : ts.SourceFile
>diagnostic : ts.Diagnostic
>file : ts.SourceFile
>fileName : string
>lineChar.line + 1 : number
>lineChar.line : number
>lineChar : ts.LineAndCharacter
>line : number
>lineChar.character + 1 : number
>lineChar.character : number
>lineChar : ts.LineAndCharacter
>character : number
>ts.flattenDiagnosticMessageText(diagnostic.messageText, "\n") : string
>ts.flattenDiagnosticMessageText : (messageText: string | ts.DiagnosticMessageChain, newLine: string) => string
>ts : typeof ts
>flattenDiagnosticMessageText : (messageText: string | ts.DiagnosticMessageChain, newLine: string) => string
>diagnostic.messageText : string | ts.DiagnosticMessageChain
>diagnostic : ts.Diagnostic
>messageText : string | ts.DiagnosticMessageChain
            }
            else {
                console.log(`  Error: ${diagnostic.messageText}`);
>console.log(`  Error: ${diagnostic.messageText}`) : any
>console.log : any
>console : any
>log : any
>diagnostic.messageText : string | ts.DiagnosticMessageChain
>diagnostic : ts.Diagnostic
>messageText : string | ts.DiagnosticMessageChain
            }
        });
    }
}

// Initialize files constituting the program as all .ts files in the current directory
var currentDirectoryFiles = fs.readdirSync(process.cwd()).
>currentDirectoryFiles : any
>fs.readdirSync(process.cwd()).    filter(fileName=> fileName.length >= 3 && fileName.substr(fileName.length - 3, 3) === ".ts") : any
>fs.readdirSync(process.cwd()).    filter : any
>fs.readdirSync(process.cwd()) : any
>fs.readdirSync : any
>fs : any
>readdirSync : any
>process.cwd() : any
>process.cwd : any
>process : any
>cwd : any

    filter(fileName=> fileName.length >= 3 && fileName.substr(fileName.length - 3, 3) === ".ts");
>filter : any
>fileName=> fileName.length >= 3 && fileName.substr(fileName.length - 3, 3) === ".ts" : (fileName: any) => boolean
>fileName : any
>fileName.length >= 3 && fileName.substr(fileName.length - 3, 3) === ".ts" : boolean
>fileName.length >= 3 : boolean
>fileName.length : any
>fileName : any
>length : any
>fileName.substr(fileName.length - 3, 3) === ".ts" : boolean
>fileName.substr(fileName.length - 3, 3) : any
>fileName.substr : any
>fileName : any
>substr : any
>fileName.length - 3 : number
>fileName.length : any
>fileName : any
>length : any

// Start the watcher
watch(currentDirectoryFiles, { module: ts.ModuleKind.CommonJS });
>watch(currentDirectoryFiles, { module: ts.ModuleKind.CommonJS }) : void
>watch : (rootFileNames: string[], options: ts.CompilerOptions) => void
>currentDirectoryFiles : any
>{ module: ts.ModuleKind.CommonJS } : { [x: string]: ts.ModuleKind; module: ts.ModuleKind; }
>module : ts.ModuleKind
>ts.ModuleKind.CommonJS : ts.ModuleKind
>ts.ModuleKind : typeof ts.ModuleKind
>ts : typeof ts
>ModuleKind : typeof ts.ModuleKind
>CommonJS : ts.ModuleKind

=== typescript.d.ts ===
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved. 
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0  
 
THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE, 
MERCHANTABLITY OR NON-INFRINGEMENT. 
 
See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

declare module "typescript" {
    interface Map<T> {
>Map : Map<T>
>T : T

        [index: string]: T;
>index : string
>T : T
    }
    interface TextRange {
>TextRange : TextRange

        pos: number;
>pos : number

        end: number;
>end : number
    }
    const enum SyntaxKind {
>SyntaxKind : SyntaxKind

        Unknown = 0,
>Unknown : SyntaxKind

        EndOfFileToken = 1,
>EndOfFileToken : SyntaxKind

        SingleLineCommentTrivia = 2,
>SingleLineCommentTrivia : SyntaxKind

        MultiLineCommentTrivia = 3,
>MultiLineCommentTrivia : SyntaxKind

        NewLineTrivia = 4,
>NewLineTrivia : SyntaxKind

        WhitespaceTrivia = 5,
>WhitespaceTrivia : SyntaxKind

        ConflictMarkerTrivia = 6,
>ConflictMarkerTrivia : SyntaxKind

        NumericLiteral = 7,
>NumericLiteral : SyntaxKind

        StringLiteral = 8,
>StringLiteral : SyntaxKind

        RegularExpressionLiteral = 9,
>RegularExpressionLiteral : SyntaxKind

        NoSubstitutionTemplateLiteral = 10,
>NoSubstitutionTemplateLiteral : SyntaxKind

        TemplateHead = 11,
>TemplateHead : SyntaxKind

        TemplateMiddle = 12,
>TemplateMiddle : SyntaxKind

        TemplateTail = 13,
>TemplateTail : SyntaxKind

        OpenBraceToken = 14,
>OpenBraceToken : SyntaxKind

        CloseBraceToken = 15,
>CloseBraceToken : SyntaxKind

        OpenParenToken = 16,
>OpenParenToken : SyntaxKind

        CloseParenToken = 17,
>CloseParenToken : SyntaxKind

        OpenBracketToken = 18,
>OpenBracketToken : SyntaxKind

        CloseBracketToken = 19,
>CloseBracketToken : SyntaxKind

        DotToken = 20,
>DotToken : SyntaxKind

        DotDotDotToken = 21,
>DotDotDotToken : SyntaxKind

        SemicolonToken = 22,
>SemicolonToken : SyntaxKind

        CommaToken = 23,
>CommaToken : SyntaxKind

        LessThanToken = 24,
>LessThanToken : SyntaxKind

        GreaterThanToken = 25,
>GreaterThanToken : SyntaxKind

        LessThanEqualsToken = 26,
>LessThanEqualsToken : SyntaxKind

        GreaterThanEqualsToken = 27,
>GreaterThanEqualsToken : SyntaxKind

        EqualsEqualsToken = 28,
>EqualsEqualsToken : SyntaxKind

        ExclamationEqualsToken = 29,
>ExclamationEqualsToken : SyntaxKind

        EqualsEqualsEqualsToken = 30,
>EqualsEqualsEqualsToken : SyntaxKind

        ExclamationEqualsEqualsToken = 31,
>ExclamationEqualsEqualsToken : SyntaxKind

        EqualsGreaterThanToken = 32,
>EqualsGreaterThanToken : SyntaxKind

        PlusToken = 33,
>PlusToken : SyntaxKind

        MinusToken = 34,
>MinusToken : SyntaxKind

        AsteriskToken = 35,
>AsteriskToken : SyntaxKind

        SlashToken = 36,
>SlashToken : SyntaxKind

        PercentToken = 37,
>PercentToken : SyntaxKind

        PlusPlusToken = 38,
>PlusPlusToken : SyntaxKind

        MinusMinusToken = 39,
>MinusMinusToken : SyntaxKind

        LessThanLessThanToken = 40,
>LessThanLessThanToken : SyntaxKind

        GreaterThanGreaterThanToken = 41,
>GreaterThanGreaterThanToken : SyntaxKind

        GreaterThanGreaterThanGreaterThanToken = 42,
>GreaterThanGreaterThanGreaterThanToken : SyntaxKind

        AmpersandToken = 43,
>AmpersandToken : SyntaxKind

        BarToken = 44,
>BarToken : SyntaxKind

        CaretToken = 45,
>CaretToken : SyntaxKind

        ExclamationToken = 46,
>ExclamationToken : SyntaxKind

        TildeToken = 47,
>TildeToken : SyntaxKind

        AmpersandAmpersandToken = 48,
>AmpersandAmpersandToken : SyntaxKind

        BarBarToken = 49,
>BarBarToken : SyntaxKind

        QuestionToken = 50,
>QuestionToken : SyntaxKind

        ColonToken = 51,
>ColonToken : SyntaxKind

        EqualsToken = 52,
>EqualsToken : SyntaxKind

        PlusEqualsToken = 53,
>PlusEqualsToken : SyntaxKind

        MinusEqualsToken = 54,
>MinusEqualsToken : SyntaxKind

        AsteriskEqualsToken = 55,
>AsteriskEqualsToken : SyntaxKind

        SlashEqualsToken = 56,
>SlashEqualsToken : SyntaxKind

        PercentEqualsToken = 57,
>PercentEqualsToken : SyntaxKind

        LessThanLessThanEqualsToken = 58,
>LessThanLessThanEqualsToken : SyntaxKind

        GreaterThanGreaterThanEqualsToken = 59,
>GreaterThanGreaterThanEqualsToken : SyntaxKind

        GreaterThanGreaterThanGreaterThanEqualsToken = 60,
>GreaterThanGreaterThanGreaterThanEqualsToken : SyntaxKind

        AmpersandEqualsToken = 61,
>AmpersandEqualsToken : SyntaxKind

        BarEqualsToken = 62,
>BarEqualsToken : SyntaxKind

        CaretEqualsToken = 63,
>CaretEqualsToken : SyntaxKind

        Identifier = 64,
>Identifier : SyntaxKind

        BreakKeyword = 65,
>BreakKeyword : SyntaxKind

        CaseKeyword = 66,
>CaseKeyword : SyntaxKind

        CatchKeyword = 67,
>CatchKeyword : SyntaxKind

        ClassKeyword = 68,
>ClassKeyword : SyntaxKind

        ConstKeyword = 69,
>ConstKeyword : SyntaxKind

        ContinueKeyword = 70,
>ContinueKeyword : SyntaxKind

        DebuggerKeyword = 71,
>DebuggerKeyword : SyntaxKind

        DefaultKeyword = 72,
>DefaultKeyword : SyntaxKind

        DeleteKeyword = 73,
>DeleteKeyword : SyntaxKind

        DoKeyword = 74,
>DoKeyword : SyntaxKind

        ElseKeyword = 75,
>ElseKeyword : SyntaxKind

        EnumKeyword = 76,
>EnumKeyword : SyntaxKind

        ExportKeyword = 77,
>ExportKeyword : SyntaxKind

        ExtendsKeyword = 78,
>ExtendsKeyword : SyntaxKind

        FalseKeyword = 79,
>FalseKeyword : SyntaxKind

        FinallyKeyword = 80,
>FinallyKeyword : SyntaxKind

        ForKeyword = 81,
>ForKeyword : SyntaxKind

        FunctionKeyword = 82,
>FunctionKeyword : SyntaxKind

        IfKeyword = 83,
>IfKeyword : SyntaxKind

        ImportKeyword = 84,
>ImportKeyword : SyntaxKind

        InKeyword = 85,
>InKeyword : SyntaxKind

        InstanceOfKeyword = 86,
>InstanceOfKeyword : SyntaxKind

        NewKeyword = 87,
>NewKeyword : SyntaxKind

        NullKeyword = 88,
>NullKeyword : SyntaxKind

        ReturnKeyword = 89,
>ReturnKeyword : SyntaxKind

        SuperKeyword = 90,
>SuperKeyword : SyntaxKind

        SwitchKeyword = 91,
>SwitchKeyword : SyntaxKind

        ThisKeyword = 92,
>ThisKeyword : SyntaxKind

        ThrowKeyword = 93,
>ThrowKeyword : SyntaxKind

        TrueKeyword = 94,
>TrueKeyword : SyntaxKind

        TryKeyword = 95,
>TryKeyword : SyntaxKind

        TypeOfKeyword = 96,
>TypeOfKeyword : SyntaxKind

        VarKeyword = 97,
>VarKeyword : SyntaxKind

        VoidKeyword = 98,
>VoidKeyword : SyntaxKind

        WhileKeyword = 99,
>WhileKeyword : SyntaxKind

        WithKeyword = 100,
>WithKeyword : SyntaxKind

        AsKeyword = 101,
>AsKeyword : SyntaxKind

        FromKeyword = 102,
>FromKeyword : SyntaxKind

        ImplementsKeyword = 103,
>ImplementsKeyword : SyntaxKind

        InterfaceKeyword = 104,
>InterfaceKeyword : SyntaxKind

        LetKeyword = 105,
>LetKeyword : SyntaxKind

        PackageKeyword = 106,
>PackageKeyword : SyntaxKind

        PrivateKeyword = 107,
>PrivateKeyword : SyntaxKind

        ProtectedKeyword = 108,
>ProtectedKeyword : SyntaxKind

        PublicKeyword = 109,
>PublicKeyword : SyntaxKind

        StaticKeyword = 110,
>StaticKeyword : SyntaxKind

        YieldKeyword = 111,
>YieldKeyword : SyntaxKind

        AnyKeyword = 112,
>AnyKeyword : SyntaxKind

        BooleanKeyword = 113,
>BooleanKeyword : SyntaxKind

        ConstructorKeyword = 114,
>ConstructorKeyword : SyntaxKind

        DeclareKeyword = 115,
>DeclareKeyword : SyntaxKind

        GetKeyword = 116,
>GetKeyword : SyntaxKind

        ModuleKeyword = 117,
>ModuleKeyword : SyntaxKind

        RequireKeyword = 118,
>RequireKeyword : SyntaxKind

        NumberKeyword = 119,
>NumberKeyword : SyntaxKind

        SetKeyword = 120,
>SetKeyword : SyntaxKind

        StringKeyword = 121,
>StringKeyword : SyntaxKind

        SymbolKeyword = 122,
>SymbolKeyword : SyntaxKind

        TypeKeyword = 123,
>TypeKeyword : SyntaxKind

        OfKeyword = 124,
>OfKeyword : SyntaxKind

        QualifiedName = 125,
>QualifiedName : SyntaxKind

        ComputedPropertyName = 126,
>ComputedPropertyName : SyntaxKind

        TypeParameter = 127,
>TypeParameter : SyntaxKind

        Parameter = 128,
>Parameter : SyntaxKind

        PropertySignature = 129,
>PropertySignature : SyntaxKind

        PropertyDeclaration = 130,
>PropertyDeclaration : SyntaxKind

        MethodSignature = 131,
>MethodSignature : SyntaxKind

        MethodDeclaration = 132,
>MethodDeclaration : SyntaxKind

        Constructor = 133,
>Constructor : SyntaxKind

        GetAccessor = 134,
>GetAccessor : SyntaxKind

        SetAccessor = 135,
>SetAccessor : SyntaxKind

        CallSignature = 136,
>CallSignature : SyntaxKind

        ConstructSignature = 137,
>ConstructSignature : SyntaxKind

        IndexSignature = 138,
>IndexSignature : SyntaxKind

        TypeReference = 139,
>TypeReference : SyntaxKind

        FunctionType = 140,
>FunctionType : SyntaxKind

        ConstructorType = 141,
>ConstructorType : SyntaxKind

        TypeQuery = 142,
>TypeQuery : SyntaxKind

        TypeLiteral = 143,
>TypeLiteral : SyntaxKind

        ArrayType = 144,
>ArrayType : SyntaxKind

        TupleType = 145,
>TupleType : SyntaxKind

        UnionType = 146,
>UnionType : SyntaxKind

        ParenthesizedType = 147,
>ParenthesizedType : SyntaxKind

        ObjectBindingPattern = 148,
>ObjectBindingPattern : SyntaxKind

        ArrayBindingPattern = 149,
>ArrayBindingPattern : SyntaxKind

        BindingElement = 150,
>BindingElement : SyntaxKind

        ArrayLiteralExpression = 151,
>ArrayLiteralExpression : SyntaxKind

        ObjectLiteralExpression = 152,
>ObjectLiteralExpression : SyntaxKind

        PropertyAccessExpression = 153,
>PropertyAccessExpression : SyntaxKind

        ElementAccessExpression = 154,
>ElementAccessExpression : SyntaxKind

        CallExpression = 155,
>CallExpression : SyntaxKind

        NewExpression = 156,
>NewExpression : SyntaxKind

        TaggedTemplateExpression = 157,
>TaggedTemplateExpression : SyntaxKind

        TypeAssertionExpression = 158,
>TypeAssertionExpression : SyntaxKind

        ParenthesizedExpression = 159,
>ParenthesizedExpression : SyntaxKind

        FunctionExpression = 160,
>FunctionExpression : SyntaxKind

        ArrowFunction = 161,
>ArrowFunction : SyntaxKind

        DeleteExpression = 162,
>DeleteExpression : SyntaxKind

        TypeOfExpression = 163,
>TypeOfExpression : SyntaxKind

        VoidExpression = 164,
>VoidExpression : SyntaxKind

        PrefixUnaryExpression = 165,
>PrefixUnaryExpression : SyntaxKind

        PostfixUnaryExpression = 166,
>PostfixUnaryExpression : SyntaxKind

        BinaryExpression = 167,
>BinaryExpression : SyntaxKind

        ConditionalExpression = 168,
>ConditionalExpression : SyntaxKind

        TemplateExpression = 169,
>TemplateExpression : SyntaxKind

        YieldExpression = 170,
>YieldExpression : SyntaxKind

        SpreadElementExpression = 171,
>SpreadElementExpression : SyntaxKind

        OmittedExpression = 172,
>OmittedExpression : SyntaxKind

        TemplateSpan = 173,
>TemplateSpan : SyntaxKind

        Block = 174,
>Block : SyntaxKind

        VariableStatement = 175,
>VariableStatement : SyntaxKind

        EmptyStatement = 176,
>EmptyStatement : SyntaxKind

        ExpressionStatement = 177,
>ExpressionStatement : SyntaxKind

        IfStatement = 178,
>IfStatement : SyntaxKind

        DoStatement = 179,
>DoStatement : SyntaxKind

        WhileStatement = 180,
>WhileStatement : SyntaxKind

        ForStatement = 181,
>ForStatement : SyntaxKind

        ForInStatement = 182,
>ForInStatement : SyntaxKind

        ForOfStatement = 183,
>ForOfStatement : SyntaxKind

        ContinueStatement = 184,
>ContinueStatement : SyntaxKind

        BreakStatement = 185,
>BreakStatement : SyntaxKind

        ReturnStatement = 186,
>ReturnStatement : SyntaxKind

        WithStatement = 187,
>WithStatement : SyntaxKind

        SwitchStatement = 188,
>SwitchStatement : SyntaxKind

        LabeledStatement = 189,
>LabeledStatement : SyntaxKind

        ThrowStatement = 190,
>ThrowStatement : SyntaxKind

        TryStatement = 191,
>TryStatement : SyntaxKind

        DebuggerStatement = 192,
>DebuggerStatement : SyntaxKind

        VariableDeclaration = 193,
>VariableDeclaration : SyntaxKind

        VariableDeclarationList = 194,
>VariableDeclarationList : SyntaxKind

        FunctionDeclaration = 195,
>FunctionDeclaration : SyntaxKind

        ClassDeclaration = 196,
>ClassDeclaration : SyntaxKind

        InterfaceDeclaration = 197,
>InterfaceDeclaration : SyntaxKind

        TypeAliasDeclaration = 198,
>TypeAliasDeclaration : SyntaxKind

        EnumDeclaration = 199,
>EnumDeclaration : SyntaxKind

        ModuleDeclaration = 200,
>ModuleDeclaration : SyntaxKind

        ModuleBlock = 201,
>ModuleBlock : SyntaxKind

        ImportEqualsDeclaration = 202,
>ImportEqualsDeclaration : SyntaxKind

        ImportDeclaration = 203,
>ImportDeclaration : SyntaxKind

        ImportClause = 204,
>ImportClause : SyntaxKind

        NamespaceImport = 205,
>NamespaceImport : SyntaxKind

        NamedImports = 206,
>NamedImports : SyntaxKind

        ImportSpecifier = 207,
>ImportSpecifier : SyntaxKind

        ExportAssignment = 208,
>ExportAssignment : SyntaxKind

        ExportDeclaration = 209,
>ExportDeclaration : SyntaxKind

        NamedExports = 210,
>NamedExports : SyntaxKind

        ExportSpecifier = 211,
>ExportSpecifier : SyntaxKind

        ExternalModuleReference = 212,
>ExternalModuleReference : SyntaxKind

        CaseClause = 213,
>CaseClause : SyntaxKind

        DefaultClause = 214,
>DefaultClause : SyntaxKind

        HeritageClause = 215,
>HeritageClause : SyntaxKind

        CatchClause = 216,
>CatchClause : SyntaxKind

        PropertyAssignment = 217,
>PropertyAssignment : SyntaxKind

        ShorthandPropertyAssignment = 218,
>ShorthandPropertyAssignment : SyntaxKind

        EnumMember = 219,
>EnumMember : SyntaxKind

        SourceFile = 220,
>SourceFile : SyntaxKind

        SyntaxList = 221,
>SyntaxList : SyntaxKind

        Count = 222,
>Count : SyntaxKind

        FirstAssignment = 52,
>FirstAssignment : SyntaxKind

        LastAssignment = 63,
>LastAssignment : SyntaxKind

        FirstReservedWord = 65,
>FirstReservedWord : SyntaxKind

        LastReservedWord = 100,
>LastReservedWord : SyntaxKind

        FirstKeyword = 65,
>FirstKeyword : SyntaxKind

        LastKeyword = 124,
>LastKeyword : SyntaxKind

        FirstFutureReservedWord = 103,
>FirstFutureReservedWord : SyntaxKind

        LastFutureReservedWord = 111,
>LastFutureReservedWord : SyntaxKind

        FirstTypeNode = 139,
>FirstTypeNode : SyntaxKind

        LastTypeNode = 147,
>LastTypeNode : SyntaxKind

        FirstPunctuation = 14,
>FirstPunctuation : SyntaxKind

        LastPunctuation = 63,
>LastPunctuation : SyntaxKind

        FirstToken = 0,
>FirstToken : SyntaxKind

        LastToken = 124,
>LastToken : SyntaxKind

        FirstTriviaToken = 2,
>FirstTriviaToken : SyntaxKind

        LastTriviaToken = 6,
>LastTriviaToken : SyntaxKind

        FirstLiteralToken = 7,
>FirstLiteralToken : SyntaxKind

        LastLiteralToken = 10,
>LastLiteralToken : SyntaxKind

        FirstTemplateToken = 10,
>FirstTemplateToken : SyntaxKind

        LastTemplateToken = 13,
>LastTemplateToken : SyntaxKind

        FirstBinaryOperator = 24,
>FirstBinaryOperator : SyntaxKind

        LastBinaryOperator = 63,
>LastBinaryOperator : SyntaxKind

        FirstNode = 125,
>FirstNode : SyntaxKind
    }
    const enum NodeFlags {
>NodeFlags : NodeFlags

        Export = 1,
>Export : NodeFlags

        Ambient = 2,
>Ambient : NodeFlags

        Public = 16,
>Public : NodeFlags

        Private = 32,
>Private : NodeFlags

        Protected = 64,
>Protected : NodeFlags

        Static = 128,
>Static : NodeFlags

        MultiLine = 256,
>MultiLine : NodeFlags

        Synthetic = 512,
>Synthetic : NodeFlags

        DeclarationFile = 1024,
>DeclarationFile : NodeFlags

        Let = 2048,
>Let : NodeFlags

        Const = 4096,
>Const : NodeFlags

        OctalLiteral = 8192,
>OctalLiteral : NodeFlags

        Modifier = 243,
>Modifier : NodeFlags

        AccessibilityModifier = 112,
>AccessibilityModifier : NodeFlags

        BlockScoped = 6144,
>BlockScoped : NodeFlags
    }
    const enum ParserContextFlags {
>ParserContextFlags : ParserContextFlags

        StrictMode = 1,
>StrictMode : ParserContextFlags

        DisallowIn = 2,
>DisallowIn : ParserContextFlags

        Yield = 4,
>Yield : ParserContextFlags

        GeneratorParameter = 8,
>GeneratorParameter : ParserContextFlags

        ThisNodeHasError = 16,
>ThisNodeHasError : ParserContextFlags

        ParserGeneratedFlags = 31,
>ParserGeneratedFlags : ParserContextFlags

        ThisNodeOrAnySubNodesHasError = 32,
>ThisNodeOrAnySubNodesHasError : ParserContextFlags

        HasAggregatedChildData = 64,
>HasAggregatedChildData : ParserContextFlags
    }
    const enum RelationComparisonResult {
>RelationComparisonResult : RelationComparisonResult

        Succeeded = 1,
>Succeeded : RelationComparisonResult

        Failed = 2,
>Failed : RelationComparisonResult

        FailedAndReported = 3,
>FailedAndReported : RelationComparisonResult
    }
    interface Node extends TextRange {
>Node : Node
>TextRange : TextRange

        kind: SyntaxKind;
>kind : SyntaxKind
>SyntaxKind : SyntaxKind

        flags: NodeFlags;
>flags : NodeFlags
>NodeFlags : NodeFlags

        parserContextFlags?: ParserContextFlags;
>parserContextFlags : ParserContextFlags
>ParserContextFlags : ParserContextFlags

        modifiers?: ModifiersArray;
>modifiers : ModifiersArray
>ModifiersArray : ModifiersArray

        id?: number;
>id : number

        parent?: Node;
>parent : Node
>Node : Node

        symbol?: Symbol;
>symbol : Symbol
>Symbol : Symbol

        locals?: SymbolTable;
>locals : SymbolTable
>SymbolTable : SymbolTable

        nextContainer?: Node;
>nextContainer : Node
>Node : Node

        localSymbol?: Symbol;
>localSymbol : Symbol
>Symbol : Symbol
    }
    interface NodeArray<T> extends Array<T>, TextRange {
>NodeArray : NodeArray<T>
>T : T
>Array : T[]
>T : T
>TextRange : TextRange

        hasTrailingComma?: boolean;
>hasTrailingComma : boolean
    }
    interface ModifiersArray extends NodeArray<Node> {
>ModifiersArray : ModifiersArray
>NodeArray : NodeArray<T>
>Node : Node

        flags: number;
>flags : number
    }
    interface Identifier extends PrimaryExpression {
>Identifier : Identifier
>PrimaryExpression : PrimaryExpression

        text: string;
>text : string
    }
    interface QualifiedName extends Node {
>QualifiedName : QualifiedName
>Node : Node

        left: EntityName;
>left : Identifier | QualifiedName
>EntityName : Identifier | QualifiedName

        right: Identifier;
>right : Identifier
>Identifier : Identifier
    }
    type EntityName = Identifier | QualifiedName;
>EntityName : Identifier | QualifiedName
>Identifier : Identifier
>QualifiedName : QualifiedName

    type DeclarationName = Identifier | LiteralExpression | ComputedPropertyName | BindingPattern;
>DeclarationName : Identifier | LiteralExpression | ComputedPropertyName | BindingPattern
>Identifier : Identifier
>LiteralExpression : LiteralExpression
>ComputedPropertyName : ComputedPropertyName
>BindingPattern : BindingPattern

    interface Declaration extends Node {
>Declaration : Declaration
>Node : Node

        _declarationBrand: any;
>_declarationBrand : any

        name?: DeclarationName;
>name : Identifier | LiteralExpression | ComputedPropertyName | BindingPattern
>DeclarationName : Identifier | LiteralExpression | ComputedPropertyName | BindingPattern
    }
    interface ComputedPropertyName extends Node {
>ComputedPropertyName : ComputedPropertyName
>Node : Node

        expression: Expression;
>expression : Expression
>Expression : Expression
    }
    interface TypeParameterDeclaration extends Declaration {
>TypeParameterDeclaration : TypeParameterDeclaration
>Declaration : Declaration

        name: Identifier;
>name : Identifier
>Identifier : Identifier

        constraint?: TypeNode;
>constraint : TypeNode
>TypeNode : TypeNode

        expression?: Expression;
>expression : Expression
>Expression : Expression
    }
    interface SignatureDeclaration extends Declaration {
>SignatureDeclaration : SignatureDeclaration
>Declaration : Declaration

        typeParameters?: NodeArray<TypeParameterDeclaration>;
>typeParameters : NodeArray<TypeParameterDeclaration>
>NodeArray : NodeArray<T>
>TypeParameterDeclaration : TypeParameterDeclaration

        parameters: NodeArray<ParameterDeclaration>;
>parameters : NodeArray<ParameterDeclaration>
>NodeArray : NodeArray<T>
>ParameterDeclaration : ParameterDeclaration

        type?: TypeNode;
>type : TypeNode
>TypeNode : TypeNode
    }
    interface VariableDeclaration extends Declaration {
>VariableDeclaration : VariableDeclaration
>Declaration : Declaration

        parent?: VariableDeclarationList;
>parent : VariableDeclarationList
>VariableDeclarationList : VariableDeclarationList

        name: Identifier | BindingPattern;
>name : Identifier | BindingPattern
>Identifier : Identifier
>BindingPattern : BindingPattern

        type?: TypeNode;
>type : TypeNode
>TypeNode : TypeNode

        initializer?: Expression;
>initializer : Expression
>Expression : Expression
    }
    interface VariableDeclarationList extends Node {
>VariableDeclarationList : VariableDeclarationList
>Node : Node

        declarations: NodeArray<VariableDeclaration>;
>declarations : NodeArray<VariableDeclaration>
>NodeArray : NodeArray<T>
>VariableDeclaration : VariableDeclaration
    }
    interface ParameterDeclaration extends Declaration {
>ParameterDeclaration : ParameterDeclaration
>Declaration : Declaration

        dotDotDotToken?: Node;
>dotDotDotToken : Node
>Node : Node

        name: Identifier | BindingPattern;
>name : Identifier | BindingPattern
>Identifier : Identifier
>BindingPattern : BindingPattern

        questionToken?: Node;
>questionToken : Node
>Node : Node

        type?: TypeNode;
>type : TypeNode
>TypeNode : TypeNode

        initializer?: Expression;
>initializer : Expression
>Expression : Expression
    }
    interface BindingElement extends Declaration {
>BindingElement : BindingElement
>Declaration : Declaration

        propertyName?: Identifier;
>propertyName : Identifier
>Identifier : Identifier

        dotDotDotToken?: Node;
>dotDotDotToken : Node
>Node : Node

        name: Identifier | BindingPattern;
>name : Identifier | BindingPattern
>Identifier : Identifier
>BindingPattern : BindingPattern

        initializer?: Expression;
>initializer : Expression
>Expression : Expression
    }
    interface PropertyDeclaration extends Declaration, ClassElement {
>PropertyDeclaration : PropertyDeclaration
>Declaration : Declaration
>ClassElement : ClassElement

        name: DeclarationName;
>name : Identifier | LiteralExpression | ComputedPropertyName | BindingPattern
>DeclarationName : Identifier | LiteralExpression | ComputedPropertyName | BindingPattern

        questionToken?: Node;
>questionToken : Node
>Node : Node

        type?: TypeNode;
>type : TypeNode
>TypeNode : TypeNode

        initializer?: Expression;
>initializer : Expression
>Expression : Expression
    }
    interface ObjectLiteralElement extends Declaration {
>ObjectLiteralElement : ObjectLiteralElement
>Declaration : Declaration

        _objectLiteralBrandBrand: any;
>_objectLiteralBrandBrand : any
    }
    interface PropertyAssignment extends ObjectLiteralElement {
>PropertyAssignment : PropertyAssignment
>ObjectLiteralElement : ObjectLiteralElement

        _propertyAssignmentBrand: any;
>_propertyAssignmentBrand : any

        name: DeclarationName;
>name : Identifier | LiteralExpression | ComputedPropertyName | BindingPattern
>DeclarationName : Identifier | LiteralExpression | ComputedPropertyName | BindingPattern

        questionToken?: Node;
>questionToken : Node
>Node : Node

        initializer: Expression;
>initializer : Expression
>Expression : Expression
    }
    interface ShorthandPropertyAssignment extends ObjectLiteralElement {
>ShorthandPropertyAssignment : ShorthandPropertyAssignment
>ObjectLiteralElement : ObjectLiteralElement

        name: Identifier;
>name : Identifier
>Identifier : Identifier

        questionToken?: Node;
>questionToken : Node
>Node : Node
    }
    interface VariableLikeDeclaration extends Declaration {
>VariableLikeDeclaration : VariableLikeDeclaration
>Declaration : Declaration

        propertyName?: Identifier;
>propertyName : Identifier
>Identifier : Identifier

        dotDotDotToken?: Node;
>dotDotDotToken : Node
>Node : Node

        name: DeclarationName;
>name : Identifier | LiteralExpression | ComputedPropertyName | BindingPattern
>DeclarationName : Identifier | LiteralExpression | ComputedPropertyName | BindingPattern

        questionToken?: Node;
>questionToken : Node
>Node : Node

        type?: TypeNode;
>type : TypeNode
>TypeNode : TypeNode

        initializer?: Expression;
>initializer : Expression
>Expression : Expression
    }
    interface BindingPattern extends Node {
>BindingPattern : BindingPattern
>Node : Node

        elements: NodeArray<BindingElement>;
>elements : NodeArray<BindingElement>
>NodeArray : NodeArray<T>
>BindingElement : BindingElement
    }
    /**
     * Several node kinds share function-like features such as a signature,
     * a name, and a body. These nodes should extend FunctionLikeDeclaration.
     * Examples:
     *  FunctionDeclaration
     *  MethodDeclaration
     *  AccessorDeclaration
     */
    interface FunctionLikeDeclaration extends SignatureDeclaration {
>FunctionLikeDeclaration : FunctionLikeDeclaration
>SignatureDeclaration : SignatureDeclaration

        _functionLikeDeclarationBrand: any;
>_functionLikeDeclarationBrand : any

        asteriskToken?: Node;
>asteriskToken : Node
>Node : Node

        questionToken?: Node;
>questionToken : Node
>Node : Node

        body?: Block | Expression;
>body : Expression | Block
>Block : Block
>Expression : Expression
    }
    interface FunctionDeclaration extends FunctionLikeDeclaration, Statement {
>FunctionDeclaration : FunctionDeclaration
>FunctionLikeDeclaration : FunctionLikeDeclaration
>Statement : Statement

        name: Identifier;
>name : Identifier
>Identifier : Identifier

        body?: Block;
>body : Block
>Block : Block
    }
    interface MethodDeclaration extends FunctionLikeDeclaration, ClassElement, ObjectLiteralElement {
>MethodDeclaration : MethodDeclaration
>FunctionLikeDeclaration : FunctionLikeDeclaration
>ClassElement : ClassElement
>ObjectLiteralElement : ObjectLiteralElement

        body?: Block;
>body : Block
>Block : Block
    }
    interface ConstructorDeclaration extends FunctionLikeDeclaration, ClassElement {
>ConstructorDeclaration : ConstructorDeclaration
>FunctionLikeDeclaration : FunctionLikeDeclaration
>ClassElement : ClassElement

        body?: Block;
>body : Block
>Block : Block
    }
    interface AccessorDeclaration extends FunctionLikeDeclaration, ClassElement, ObjectLiteralElement {
>AccessorDeclaration : AccessorDeclaration
>FunctionLikeDeclaration : FunctionLikeDeclaration
>ClassElement : ClassElement
>ObjectLiteralElement : ObjectLiteralElement

        _accessorDeclarationBrand: any;
>_accessorDeclarationBrand : any

        body: Block;
>body : Block
>Block : Block
    }
    interface IndexSignatureDeclaration extends SignatureDeclaration, ClassElement {
>IndexSignatureDeclaration : IndexSignatureDeclaration
>SignatureDeclaration : SignatureDeclaration
>ClassElement : ClassElement

        _indexSignatureDeclarationBrand: any;
>_indexSignatureDeclarationBrand : any
    }
    interface TypeNode extends Node {
>TypeNode : TypeNode
>Node : Node

        _typeNodeBrand: any;
>_typeNodeBrand : any
    }
    interface FunctionOrConstructorTypeNode extends TypeNode, SignatureDeclaration {
>FunctionOrConstructorTypeNode : FunctionOrConstructorTypeNode
>TypeNode : TypeNode
>SignatureDeclaration : SignatureDeclaration

        _functionOrConstructorTypeNodeBrand: any;
>_functionOrConstructorTypeNodeBrand : any
    }
    interface TypeReferenceNode extends TypeNode {
>TypeReferenceNode : TypeReferenceNode
>TypeNode : TypeNode

        typeName: EntityName;
>typeName : Identifier | QualifiedName
>EntityName : Identifier | QualifiedName

        typeArguments?: NodeArray<TypeNode>;
>typeArguments : NodeArray<TypeNode>
>NodeArray : NodeArray<T>
>TypeNode : TypeNode
    }
    interface TypeQueryNode extends TypeNode {
>TypeQueryNode : TypeQueryNode
>TypeNode : TypeNode

        exprName: EntityName;
>exprName : Identifier | QualifiedName
>EntityName : Identifier | QualifiedName
    }
    interface TypeLiteralNode extends TypeNode, Declaration {
>TypeLiteralNode : TypeLiteralNode
>TypeNode : TypeNode
>Declaration : Declaration

        members: NodeArray<Node>;
>members : NodeArray<Node>
>NodeArray : NodeArray<T>
>Node : Node
    }
    interface ArrayTypeNode extends TypeNode {
>ArrayTypeNode : ArrayTypeNode
>TypeNode : TypeNode

        elementType: TypeNode;
>elementType : TypeNode
>TypeNode : TypeNode
    }
    interface TupleTypeNode extends TypeNode {
>TupleTypeNode : TupleTypeNode
>TypeNode : TypeNode

        elementTypes: NodeArray<TypeNode>;
>elementTypes : NodeArray<TypeNode>
>NodeArray : NodeArray<T>
>TypeNode : TypeNode
    }
    interface UnionTypeNode extends TypeNode {
>UnionTypeNode : UnionTypeNode
>TypeNode : TypeNode

        types: NodeArray<TypeNode>;
>types : NodeArray<TypeNode>
>NodeArray : NodeArray<T>
>TypeNode : TypeNode
    }
    interface ParenthesizedTypeNode extends TypeNode {
>ParenthesizedTypeNode : ParenthesizedTypeNode
>TypeNode : TypeNode

        type: TypeNode;
>type : TypeNode
>TypeNode : TypeNode
    }
    interface StringLiteralTypeNode extends LiteralExpression, TypeNode {
>StringLiteralTypeNode : StringLiteralTypeNode
>LiteralExpression : LiteralExpression
>TypeNode : TypeNode
    }
    interface Expression extends Node {
>Expression : Expression
>Node : Node

        _expressionBrand: any;
>_expressionBrand : any

        contextualType?: Type;
>contextualType : Type
>Type : Type
    }
    interface UnaryExpression extends Expression {
>UnaryExpression : UnaryExpression
>Expression : Expression

        _unaryExpressionBrand: any;
>_unaryExpressionBrand : any
    }
    interface PrefixUnaryExpression extends UnaryExpression {
>PrefixUnaryExpression : PrefixUnaryExpression
>UnaryExpression : UnaryExpression

        operator: SyntaxKind;
>operator : SyntaxKind
>SyntaxKind : SyntaxKind

        operand: UnaryExpression;
>operand : UnaryExpression
>UnaryExpression : UnaryExpression
    }
    interface PostfixUnaryExpression extends PostfixExpression {
>PostfixUnaryExpression : PostfixUnaryExpression
>PostfixExpression : PostfixExpression

        operand: LeftHandSideExpression;
>operand : LeftHandSideExpression
>LeftHandSideExpression : LeftHandSideExpression

        operator: SyntaxKind;
>operator : SyntaxKind
>SyntaxKind : SyntaxKind
    }
    interface PostfixExpression extends UnaryExpression {
>PostfixExpression : PostfixExpression
>UnaryExpression : UnaryExpression

        _postfixExpressionBrand: any;
>_postfixExpressionBrand : any
    }
    interface LeftHandSideExpression extends PostfixExpression {
>LeftHandSideExpression : LeftHandSideExpression
>PostfixExpression : PostfixExpression

        _leftHandSideExpressionBrand: any;
>_leftHandSideExpressionBrand : any
    }
    interface MemberExpression extends LeftHandSideExpression {
>MemberExpression : MemberExpression
>LeftHandSideExpression : LeftHandSideExpression

        _memberExpressionBrand: any;
>_memberExpressionBrand : any
    }
    interface PrimaryExpression extends MemberExpression {
>PrimaryExpression : PrimaryExpression
>MemberExpression : MemberExpression

        _primaryExpressionBrand: any;
>_primaryExpressionBrand : any
    }
    interface DeleteExpression extends UnaryExpression {
>DeleteExpression : DeleteExpression
>UnaryExpression : UnaryExpression

        expression: UnaryExpression;
>expression : UnaryExpression
>UnaryExpression : UnaryExpression
    }
    interface TypeOfExpression extends UnaryExpression {
>TypeOfExpression : TypeOfExpression
>UnaryExpression : UnaryExpression

        expression: UnaryExpression;
>expression : UnaryExpression
>UnaryExpression : UnaryExpression
    }
    interface VoidExpression extends UnaryExpression {
>VoidExpression : VoidExpression
>UnaryExpression : UnaryExpression

        expression: UnaryExpression;
>expression : UnaryExpression
>UnaryExpression : UnaryExpression
    }
    interface YieldExpression extends Expression {
>YieldExpression : YieldExpression
>Expression : Expression

        asteriskToken?: Node;
>asteriskToken : Node
>Node : Node

        expression: Expression;
>expression : Expression
>Expression : Expression
    }
    interface BinaryExpression extends Expression {
>BinaryExpression : BinaryExpression
>Expression : Expression

        left: Expression;
>left : Expression
>Expression : Expression

        operatorToken: Node;
>operatorToken : Node
>Node : Node

        right: Expression;
>right : Expression
>Expression : Expression
    }
    interface ConditionalExpression extends Expression {
>ConditionalExpression : ConditionalExpression
>Expression : Expression

        condition: Expression;
>condition : Expression
>Expression : Expression

        whenTrue: Expression;
>whenTrue : Expression
>Expression : Expression

        whenFalse: Expression;
>whenFalse : Expression
>Expression : Expression
    }
    interface FunctionExpression extends PrimaryExpression, FunctionLikeDeclaration {
>FunctionExpression : FunctionExpression
>PrimaryExpression : PrimaryExpression
>FunctionLikeDeclaration : FunctionLikeDeclaration

        name?: Identifier;
>name : Identifier
>Identifier : Identifier

        body: Block | Expression;
>body : Expression | Block
>Block : Block
>Expression : Expression
    }
    interface LiteralExpression extends PrimaryExpression {
>LiteralExpression : LiteralExpression
>PrimaryExpression : PrimaryExpression

        text: string;
>text : string

        isUnterminated?: boolean;
>isUnterminated : boolean
    }
    interface StringLiteralExpression extends LiteralExpression {
>StringLiteralExpression : StringLiteralExpression
>LiteralExpression : LiteralExpression

        _stringLiteralExpressionBrand: any;
>_stringLiteralExpressionBrand : any
    }
    interface TemplateExpression extends PrimaryExpression {
>TemplateExpression : TemplateExpression
>PrimaryExpression : PrimaryExpression

        head: LiteralExpression;
>head : LiteralExpression
>LiteralExpression : LiteralExpression

        templateSpans: NodeArray<TemplateSpan>;
>templateSpans : NodeArray<TemplateSpan>
>NodeArray : NodeArray<T>
>TemplateSpan : TemplateSpan
    }
    interface TemplateSpan extends Node {
>TemplateSpan : TemplateSpan
>Node : Node

        expression: Expression;
>expression : Expression
>Expression : Expression

        literal: LiteralExpression;
>literal : LiteralExpression
>LiteralExpression : LiteralExpression
    }
    interface ParenthesizedExpression extends PrimaryExpression {
>ParenthesizedExpression : ParenthesizedExpression
>PrimaryExpression : PrimaryExpression

        expression: Expression;
>expression : Expression
>Expression : Expression
    }
    interface ArrayLiteralExpression extends PrimaryExpression {
>ArrayLiteralExpression : ArrayLiteralExpression
>PrimaryExpression : PrimaryExpression

        elements: NodeArray<Expression>;
>elements : NodeArray<Expression>
>NodeArray : NodeArray<T>
>Expression : Expression
    }
    interface SpreadElementExpression extends Expression {
>SpreadElementExpression : SpreadElementExpression
>Expression : Expression

        expression: Expression;
>expression : Expression
>Expression : Expression
    }
    interface ObjectLiteralExpression extends PrimaryExpression, Declaration {
>ObjectLiteralExpression : ObjectLiteralExpression
>PrimaryExpression : PrimaryExpression
>Declaration : Declaration

        properties: NodeArray<ObjectLiteralElement>;
>properties : NodeArray<ObjectLiteralElement>
>NodeArray : NodeArray<T>
>ObjectLiteralElement : ObjectLiteralElement
    }
    interface PropertyAccessExpression extends MemberExpression {
>PropertyAccessExpression : PropertyAccessExpression
>MemberExpression : MemberExpression

        expression: LeftHandSideExpression;
>expression : LeftHandSideExpression
>LeftHandSideExpression : LeftHandSideExpression

        name: Identifier;
>name : Identifier
>Identifier : Identifier
    }
    interface ElementAccessExpression extends MemberExpression {
>ElementAccessExpression : ElementAccessExpression
>MemberExpression : MemberExpression

        expression: LeftHandSideExpression;
>expression : LeftHandSideExpression
>LeftHandSideExpression : LeftHandSideExpression

        argumentExpression?: Expression;
>argumentExpression : Expression
>Expression : Expression
    }
    interface CallExpression extends LeftHandSideExpression {
>CallExpression : CallExpression
>LeftHandSideExpression : LeftHandSideExpression

        expression: LeftHandSideExpression;
>expression : LeftHandSideExpression
>LeftHandSideExpression : LeftHandSideExpression

        typeArguments?: NodeArray<TypeNode>;
>typeArguments : NodeArray<TypeNode>
>NodeArray : NodeArray<T>
>TypeNode : TypeNode

        arguments: NodeArray<Expression>;
>arguments : NodeArray<Expression>
>NodeArray : NodeArray<T>
>Expression : Expression
    }
    interface NewExpression extends CallExpression, PrimaryExpression {
>NewExpression : NewExpression
>CallExpression : CallExpression
>PrimaryExpression : PrimaryExpression
    }
    interface TaggedTemplateExpression extends MemberExpression {
>TaggedTemplateExpression : TaggedTemplateExpression
>MemberExpression : MemberExpression

        tag: LeftHandSideExpression;
>tag : LeftHandSideExpression
>LeftHandSideExpression : LeftHandSideExpression

        template: LiteralExpression | TemplateExpression;
>template : LiteralExpression | TemplateExpression
>LiteralExpression : LiteralExpression
>TemplateExpression : TemplateExpression
    }
    type CallLikeExpression = CallExpression | NewExpression | TaggedTemplateExpression;
>CallLikeExpression : CallExpression | NewExpression | TaggedTemplateExpression
>CallExpression : CallExpression
>NewExpression : NewExpression
>TaggedTemplateExpression : TaggedTemplateExpression

    interface TypeAssertion extends UnaryExpression {
>TypeAssertion : TypeAssertion
>UnaryExpression : UnaryExpression

        type: TypeNode;
>type : TypeNode
>TypeNode : TypeNode

        expression: UnaryExpression;
>expression : UnaryExpression
>UnaryExpression : UnaryExpression
    }
    interface Statement extends Node, ModuleElement {
>Statement : Statement
>Node : Node
>ModuleElement : ModuleElement

        _statementBrand: any;
>_statementBrand : any
    }
    interface Block extends Statement {
>Block : Block
>Statement : Statement

        statements: NodeArray<Statement>;
>statements : NodeArray<Statement>
>NodeArray : NodeArray<T>
>Statement : Statement
    }
    interface VariableStatement extends Statement {
>VariableStatement : VariableStatement
>Statement : Statement

        declarationList: VariableDeclarationList;
>declarationList : VariableDeclarationList
>VariableDeclarationList : VariableDeclarationList
    }
    interface ExpressionStatement extends Statement {
>ExpressionStatement : ExpressionStatement
>Statement : Statement

        expression: Expression;
>expression : Expression
>Expression : Expression
    }
    interface IfStatement extends Statement {
>IfStatement : IfStatement
>Statement : Statement

        expression: Expression;
>expression : Expression
>Expression : Expression

        thenStatement: Statement;
>thenStatement : Statement
>Statement : Statement

        elseStatement?: Statement;
>elseStatement : Statement
>Statement : Statement
    }
    interface IterationStatement extends Statement {
>IterationStatement : IterationStatement
>Statement : Statement

        statement: Statement;
>statement : Statement
>Statement : Statement
    }
    interface DoStatement extends IterationStatement {
>DoStatement : DoStatement
>IterationStatement : IterationStatement

        expression: Expression;
>expression : Expression
>Expression : Expression
    }
    interface WhileStatement extends IterationStatement {
>WhileStatement : WhileStatement
>IterationStatement : IterationStatement

        expression: Expression;
>expression : Expression
>Expression : Expression
    }
    interface ForStatement extends IterationStatement {
>ForStatement : ForStatement
>IterationStatement : IterationStatement

        initializer?: VariableDeclarationList | Expression;
>initializer : Expression | VariableDeclarationList
>VariableDeclarationList : VariableDeclarationList
>Expression : Expression

        condition?: Expression;
>condition : Expression
>Expression : Expression

        iterator?: Expression;
>iterator : Expression
>Expression : Expression
    }
    interface ForInStatement extends IterationStatement {
>ForInStatement : ForInStatement
>IterationStatement : IterationStatement

        initializer: VariableDeclarationList | Expression;
>initializer : Expression | VariableDeclarationList
>VariableDeclarationList : VariableDeclarationList
>Expression : Expression

        expression: Expression;
>expression : Expression
>Expression : Expression
    }
    interface ForOfStatement extends IterationStatement {
>ForOfStatement : ForOfStatement
>IterationStatement : IterationStatement

        initializer: VariableDeclarationList | Expression;
>initializer : Expression | VariableDeclarationList
>VariableDeclarationList : VariableDeclarationList
>Expression : Expression

        expression: Expression;
>expression : Expression
>Expression : Expression
    }
    interface BreakOrContinueStatement extends Statement {
>BreakOrContinueStatement : BreakOrContinueStatement
>Statement : Statement

        label?: Identifier;
>label : Identifier
>Identifier : Identifier
    }
    interface ReturnStatement extends Statement {
>ReturnStatement : ReturnStatement
>Statement : Statement

        expression?: Expression;
>expression : Expression
>Expression : Expression
    }
    interface WithStatement extends Statement {
>WithStatement : WithStatement
>Statement : Statement

        expression: Expression;
>expression : Expression
>Expression : Expression

        statement: Statement;
>statement : Statement
>Statement : Statement
    }
    interface SwitchStatement extends Statement {
>SwitchStatement : SwitchStatement
>Statement : Statement

        expression: Expression;
>expression : Expression
>Expression : Expression

        clauses: NodeArray<CaseOrDefaultClause>;
>clauses : NodeArray<CaseClause | DefaultClause>
>NodeArray : NodeArray<T>
>CaseOrDefaultClause : CaseClause | DefaultClause
    }
    interface CaseClause extends Node {
>CaseClause : CaseClause
>Node : Node

        expression?: Expression;
>expression : Expression
>Expression : Expression

        statements: NodeArray<Statement>;
>statements : NodeArray<Statement>
>NodeArray : NodeArray<T>
>Statement : Statement
    }
    interface DefaultClause extends Node {
>DefaultClause : DefaultClause
>Node : Node

        statements: NodeArray<Statement>;
>statements : NodeArray<Statement>
>NodeArray : NodeArray<T>
>Statement : Statement
    }
    type CaseOrDefaultClause = CaseClause | DefaultClause;
>CaseOrDefaultClause : CaseClause | DefaultClause
>CaseClause : CaseClause
>DefaultClause : DefaultClause

    interface LabeledStatement extends Statement {
>LabeledStatement : LabeledStatement
>Statement : Statement

        label: Identifier;
>label : Identifier
>Identifier : Identifier

        statement: Statement;
>statement : Statement
>Statement : Statement
    }
    interface ThrowStatement extends Statement {
>ThrowStatement : ThrowStatement
>Statement : Statement

        expression: Expression;
>expression : Expression
>Expression : Expression
    }
    interface TryStatement extends Statement {
>TryStatement : TryStatement
>Statement : Statement

        tryBlock: Block;
>tryBlock : Block
>Block : Block

        catchClause?: CatchClause;
>catchClause : CatchClause
>CatchClause : CatchClause

        finallyBlock?: Block;
>finallyBlock : Block
>Block : Block
    }
    interface CatchClause extends Declaration {
>CatchClause : CatchClause
>Declaration : Declaration

        name: Identifier;
>name : Identifier
>Identifier : Identifier

        type?: TypeNode;
>type : TypeNode
>TypeNode : TypeNode

        block: Block;
>block : Block
>Block : Block
    }
    interface ModuleElement extends Node {
>ModuleElement : ModuleElement
>Node : Node

        _moduleElementBrand: any;
>_moduleElementBrand : any
    }
    interface ClassDeclaration extends Declaration, ModuleElement {
>ClassDeclaration : ClassDeclaration
>Declaration : Declaration
>ModuleElement : ModuleElement

        name: Identifier;
>name : Identifier
>Identifier : Identifier

        typeParameters?: NodeArray<TypeParameterDeclaration>;
>typeParameters : NodeArray<TypeParameterDeclaration>
>NodeArray : NodeArray<T>
>TypeParameterDeclaration : TypeParameterDeclaration

        heritageClauses?: NodeArray<HeritageClause>;
>heritageClauses : NodeArray<HeritageClause>
>NodeArray : NodeArray<T>
>HeritageClause : HeritageClause

        members: NodeArray<ClassElement>;
>members : NodeArray<ClassElement>
>NodeArray : NodeArray<T>
>ClassElement : ClassElement
    }
    interface ClassElement extends Declaration {
>ClassElement : ClassElement
>Declaration : Declaration

        _classElementBrand: any;
>_classElementBrand : any
    }
    interface InterfaceDeclaration extends Declaration, ModuleElement {
>InterfaceDeclaration : InterfaceDeclaration
>Declaration : Declaration
>ModuleElement : ModuleElement

        name: Identifier;
>name : Identifier
>Identifier : Identifier

        typeParameters?: NodeArray<TypeParameterDeclaration>;
>typeParameters : NodeArray<TypeParameterDeclaration>
>NodeArray : NodeArray<T>
>TypeParameterDeclaration : TypeParameterDeclaration

        heritageClauses?: NodeArray<HeritageClause>;
>heritageClauses : NodeArray<HeritageClause>
>NodeArray : NodeArray<T>
>HeritageClause : HeritageClause

        members: NodeArray<Declaration>;
>members : NodeArray<Declaration>
>NodeArray : NodeArray<T>
>Declaration : Declaration
    }
    interface HeritageClause extends Node {
>HeritageClause : HeritageClause
>Node : Node

        token: SyntaxKind;
>token : SyntaxKind
>SyntaxKind : SyntaxKind

        types?: NodeArray<TypeReferenceNode>;
>types : NodeArray<TypeReferenceNode>
>NodeArray : NodeArray<T>
>TypeReferenceNode : TypeReferenceNode
    }
    interface TypeAliasDeclaration extends Declaration, ModuleElement {
>TypeAliasDeclaration : TypeAliasDeclaration
>Declaration : Declaration
>ModuleElement : ModuleElement

        name: Identifier;
>name : Identifier
>Identifier : Identifier

        type: TypeNode;
>type : TypeNode
>TypeNode : TypeNode
    }
    interface EnumMember extends Declaration {
>EnumMember : EnumMember
>Declaration : Declaration

        name: DeclarationName;
>name : Identifier | LiteralExpression | ComputedPropertyName | BindingPattern
>DeclarationName : Identifier | LiteralExpression | ComputedPropertyName | BindingPattern

        initializer?: Expression;
>initializer : Expression
>Expression : Expression
    }
    interface EnumDeclaration extends Declaration, ModuleElement {
>EnumDeclaration : EnumDeclaration
>Declaration : Declaration
>ModuleElement : ModuleElement

        name: Identifier;
>name : Identifier
>Identifier : Identifier

        members: NodeArray<EnumMember>;
>members : NodeArray<EnumMember>
>NodeArray : NodeArray<T>
>EnumMember : EnumMember
    }
    interface ExportContainer {
>ExportContainer : ExportContainer

        exportStars?: ExportDeclaration[];
>exportStars : ExportDeclaration[]
>ExportDeclaration : ExportDeclaration
    }
    interface ModuleDeclaration extends Declaration, ModuleElement, ExportContainer {
>ModuleDeclaration : ModuleDeclaration
>Declaration : Declaration
>ModuleElement : ModuleElement
>ExportContainer : ExportContainer

        name: Identifier | LiteralExpression;
>name : Identifier | LiteralExpression
>Identifier : Identifier
>LiteralExpression : LiteralExpression

        body: ModuleBlock | ModuleDeclaration;
>body : ModuleDeclaration | ModuleBlock
>ModuleBlock : ModuleBlock
>ModuleDeclaration : ModuleDeclaration
    }
    interface ModuleBlock extends Node, ModuleElement {
>ModuleBlock : ModuleBlock
>Node : Node
>ModuleElement : ModuleElement

        statements: NodeArray<ModuleElement>;
>statements : NodeArray<ModuleElement>
>NodeArray : NodeArray<T>
>ModuleElement : ModuleElement
    }
    interface ImportEqualsDeclaration extends Declaration, ModuleElement {
>ImportEqualsDeclaration : ImportEqualsDeclaration
>Declaration : Declaration
>ModuleElement : ModuleElement

        name: Identifier;
>name : Identifier
>Identifier : Identifier

        moduleReference: EntityName | ExternalModuleReference;
>moduleReference : Identifier | QualifiedName | ExternalModuleReference
>EntityName : Identifier | QualifiedName
>ExternalModuleReference : ExternalModuleReference
    }
    interface ExternalModuleReference extends Node {
>ExternalModuleReference : ExternalModuleReference
>Node : Node

        expression?: Expression;
>expression : Expression
>Expression : Expression
    }
    interface ImportDeclaration extends Statement, ModuleElement {
>ImportDeclaration : ImportDeclaration
>Statement : Statement
>ModuleElement : ModuleElement

        importClause?: ImportClause;
>importClause : ImportClause
>ImportClause : ImportClause

        moduleSpecifier: Expression;
>moduleSpecifier : Expression
>Expression : Expression
    }
    interface ImportClause extends Declaration {
>ImportClause : ImportClause
>Declaration : Declaration

        name?: Identifier;
>name : Identifier
>Identifier : Identifier

        namedBindings?: NamespaceImport | NamedImports;
>namedBindings : NamespaceImport | NamedImportsOrExports
>NamespaceImport : NamespaceImport
>NamedImports : NamedImportsOrExports
    }
    interface NamespaceImport extends Declaration {
>NamespaceImport : NamespaceImport
>Declaration : Declaration

        name: Identifier;
>name : Identifier
>Identifier : Identifier
    }
    interface ExportDeclaration extends Statement, ModuleElement {
>ExportDeclaration : ExportDeclaration
>Statement : Statement
>ModuleElement : ModuleElement

        exportClause?: NamedExports;
>exportClause : NamedImportsOrExports
>NamedExports : NamedImportsOrExports

        moduleSpecifier?: Expression;
>moduleSpecifier : Expression
>Expression : Expression
    }
    interface NamedImportsOrExports extends Node {
>NamedImportsOrExports : NamedImportsOrExports
>Node : Node

        elements: NodeArray<ImportOrExportSpecifier>;
>elements : NodeArray<ImportOrExportSpecifier>
>NodeArray : NodeArray<T>
>ImportOrExportSpecifier : ImportOrExportSpecifier
    }
    type NamedImports = NamedImportsOrExports;
>NamedImports : NamedImportsOrExports
>NamedImportsOrExports : NamedImportsOrExports

    type NamedExports = NamedImportsOrExports;
>NamedExports : NamedImportsOrExports
>NamedImportsOrExports : NamedImportsOrExports

    interface ImportOrExportSpecifier extends Declaration {
>ImportOrExportSpecifier : ImportOrExportSpecifier
>Declaration : Declaration

        propertyName?: Identifier;
>propertyName : Identifier
>Identifier : Identifier

        name: Identifier;
>name : Identifier
>Identifier : Identifier
    }
    type ImportSpecifier = ImportOrExportSpecifier;
>ImportSpecifier : ImportOrExportSpecifier
>ImportOrExportSpecifier : ImportOrExportSpecifier

    type ExportSpecifier = ImportOrExportSpecifier;
>ExportSpecifier : ImportOrExportSpecifier
>ImportOrExportSpecifier : ImportOrExportSpecifier

    interface ExportAssignment extends Statement, ModuleElement {
>ExportAssignment : ExportAssignment
>Statement : Statement
>ModuleElement : ModuleElement

        exportName: Identifier;
>exportName : Identifier
>Identifier : Identifier
    }
    interface FileReference extends TextRange {
>FileReference : FileReference
>TextRange : TextRange

        fileName: string;
>fileName : string
    }
    interface CommentRange extends TextRange {
>CommentRange : CommentRange
>TextRange : TextRange

        hasTrailingNewLine?: boolean;
>hasTrailingNewLine : boolean
    }
    interface SourceFile extends Declaration, ExportContainer {
>SourceFile : SourceFile
>Declaration : Declaration
>ExportContainer : ExportContainer

        statements: NodeArray<ModuleElement>;
>statements : NodeArray<ModuleElement>
>NodeArray : NodeArray<T>
>ModuleElement : ModuleElement

        endOfFileToken: Node;
>endOfFileToken : Node
>Node : Node

        fileName: string;
>fileName : string

        text: string;
>text : string

        amdDependencies: {
>amdDependencies : { path: string; name: string; }[]

            path: string;
>path : string

            name: string;
>name : string

        }[];
        amdModuleName: string;
>amdModuleName : string

        referencedFiles: FileReference[];
>referencedFiles : FileReference[]
>FileReference : FileReference

        hasNoDefaultLib: boolean;
>hasNoDefaultLib : boolean

        externalModuleIndicator: Node;
>externalModuleIndicator : Node
>Node : Node

        languageVersion: ScriptTarget;
>languageVersion : ScriptTarget
>ScriptTarget : ScriptTarget

        identifiers: Map<string>;
>identifiers : Map<string>
>Map : Map<T>
    }
    interface ScriptReferenceHost {
>ScriptReferenceHost : ScriptReferenceHost

        getCompilerOptions(): CompilerOptions;
>getCompilerOptions : () => CompilerOptions
>CompilerOptions : CompilerOptions

        getSourceFile(fileName: string): SourceFile;
>getSourceFile : (fileName: string) => SourceFile
>fileName : string
>SourceFile : SourceFile

        getCurrentDirectory(): string;
>getCurrentDirectory : () => string
    }
    interface WriteFileCallback {
>WriteFileCallback : WriteFileCallback

        (fileName: string, data: string, writeByteOrderMark: boolean, onError?: (message: string) => void): void;
>fileName : string
>data : string
>writeByteOrderMark : boolean
>onError : (message: string) => void
>message : string
    }
    interface Program extends ScriptReferenceHost {
>Program : Program
>ScriptReferenceHost : ScriptReferenceHost

        getSourceFiles(): SourceFile[];
>getSourceFiles : () => SourceFile[]
>SourceFile : SourceFile

        /**
         * Emits the javascript and declaration files.  If targetSourceFile is not specified, then
         * the javascript and declaration files will be produced for all the files in this program.
         * If targetSourceFile is specified, then only the javascript and declaration for that
         * specific file will be generated.
         *
         * If writeFile is not specified then the writeFile callback from the compiler host will be
         * used for writing the javascript and declaration files.  Otherwise, the writeFile parameter
         * will be invoked when writing the javascript and declaration files.
         */
        emit(targetSourceFile?: SourceFile, writeFile?: WriteFileCallback): EmitResult;
>emit : (targetSourceFile?: SourceFile, writeFile?: WriteFileCallback) => EmitResult
>targetSourceFile : SourceFile
>SourceFile : SourceFile
>writeFile : WriteFileCallback
>WriteFileCallback : WriteFileCallback
>EmitResult : EmitResult

        getSyntacticDiagnostics(sourceFile?: SourceFile): Diagnostic[];
>getSyntacticDiagnostics : (sourceFile?: SourceFile) => Diagnostic[]
>sourceFile : SourceFile
>SourceFile : SourceFile
>Diagnostic : Diagnostic

        getGlobalDiagnostics(): Diagnostic[];
>getGlobalDiagnostics : () => Diagnostic[]
>Diagnostic : Diagnostic

        getSemanticDiagnostics(sourceFile?: SourceFile): Diagnostic[];
>getSemanticDiagnostics : (sourceFile?: SourceFile) => Diagnostic[]
>sourceFile : SourceFile
>SourceFile : SourceFile
>Diagnostic : Diagnostic

        getDeclarationDiagnostics(sourceFile?: SourceFile): Diagnostic[];
>getDeclarationDiagnostics : (sourceFile?: SourceFile) => Diagnostic[]
>sourceFile : SourceFile
>SourceFile : SourceFile
>Diagnostic : Diagnostic

        getTypeChecker(): TypeChecker;
>getTypeChecker : () => TypeChecker
>TypeChecker : TypeChecker

        getCommonSourceDirectory(): string;
>getCommonSourceDirectory : () => string
    }
    interface SourceMapSpan {
>SourceMapSpan : SourceMapSpan

        emittedLine: number;
>emittedLine : number

        emittedColumn: number;
>emittedColumn : number

        sourceLine: number;
>sourceLine : number

        sourceColumn: number;
>sourceColumn : number

        nameIndex?: number;
>nameIndex : number

        sourceIndex: number;
>sourceIndex : number
    }
    interface SourceMapData {
>SourceMapData : SourceMapData

        sourceMapFilePath: string;
>sourceMapFilePath : string

        jsSourceMappingURL: string;
>jsSourceMappingURL : string

        sourceMapFile: string;
>sourceMapFile : string

        sourceMapSourceRoot: string;
>sourceMapSourceRoot : string

        sourceMapSources: string[];
>sourceMapSources : string[]

        inputSourceFileNames: string[];
>inputSourceFileNames : string[]

        sourceMapNames?: string[];
>sourceMapNames : string[]

        sourceMapMappings: string;
>sourceMapMappings : string

        sourceMapDecodedMappings: SourceMapSpan[];
>sourceMapDecodedMappings : SourceMapSpan[]
>SourceMapSpan : SourceMapSpan
    }
    enum ExitStatus {
>ExitStatus : ExitStatus

        Success = 0,
>Success : ExitStatus

        DiagnosticsPresent_OutputsSkipped = 1,
>DiagnosticsPresent_OutputsSkipped : ExitStatus

        DiagnosticsPresent_OutputsGenerated = 2,
>DiagnosticsPresent_OutputsGenerated : ExitStatus
    }
    interface EmitResult {
>EmitResult : EmitResult

        emitSkipped: boolean;
>emitSkipped : boolean

        diagnostics: Diagnostic[];
>diagnostics : Diagnostic[]
>Diagnostic : Diagnostic

        sourceMaps: SourceMapData[];
>sourceMaps : SourceMapData[]
>SourceMapData : SourceMapData
    }
    interface TypeCheckerHost {
>TypeCheckerHost : TypeCheckerHost

        getCompilerOptions(): CompilerOptions;
>getCompilerOptions : () => CompilerOptions
>CompilerOptions : CompilerOptions

        getSourceFiles(): SourceFile[];
>getSourceFiles : () => SourceFile[]
>SourceFile : SourceFile

        getSourceFile(fileName: string): SourceFile;
>getSourceFile : (fileName: string) => SourceFile
>fileName : string
>SourceFile : SourceFile
    }
    interface TypeChecker {
>TypeChecker : TypeChecker

        getTypeOfSymbolAtLocation(symbol: Symbol, node: Node): Type;
>getTypeOfSymbolAtLocation : (symbol: Symbol, node: Node) => Type
>symbol : Symbol
>Symbol : Symbol
>node : Node
>Node : Node
>Type : Type

        getDeclaredTypeOfSymbol(symbol: Symbol): Type;
>getDeclaredTypeOfSymbol : (symbol: Symbol) => Type
>symbol : Symbol
>Symbol : Symbol
>Type : Type

        getPropertiesOfType(type: Type): Symbol[];
>getPropertiesOfType : (type: Type) => Symbol[]
>type : Type
>Type : Type
>Symbol : Symbol

        getPropertyOfType(type: Type, propertyName: string): Symbol;
>getPropertyOfType : (type: Type, propertyName: string) => Symbol
>type : Type
>Type : Type
>propertyName : string
>Symbol : Symbol

        getSignaturesOfType(type: Type, kind: SignatureKind): Signature[];
>getSignaturesOfType : (type: Type, kind: SignatureKind) => Signature[]
>type : Type
>Type : Type
>kind : SignatureKind
>SignatureKind : SignatureKind
>Signature : Signature

        getIndexTypeOfType(type: Type, kind: IndexKind): Type;
>getIndexTypeOfType : (type: Type, kind: IndexKind) => Type
>type : Type
>Type : Type
>kind : IndexKind
>IndexKind : IndexKind
>Type : Type

        getReturnTypeOfSignature(signature: Signature): Type;
>getReturnTypeOfSignature : (signature: Signature) => Type
>signature : Signature
>Signature : Signature
>Type : Type

        getSymbolsInScope(location: Node, meaning: SymbolFlags): Symbol[];
>getSymbolsInScope : (location: Node, meaning: SymbolFlags) => Symbol[]
>location : Node
>Node : Node
>meaning : SymbolFlags
>SymbolFlags : SymbolFlags
>Symbol : Symbol

        getSymbolAtLocation(node: Node): Symbol;
>getSymbolAtLocation : (node: Node) => Symbol
>node : Node
>Node : Node
>Symbol : Symbol

        getShorthandAssignmentValueSymbol(location: Node): Symbol;
>getShorthandAssignmentValueSymbol : (location: Node) => Symbol
>location : Node
>Node : Node
>Symbol : Symbol

        getTypeAtLocation(node: Node): Type;
>getTypeAtLocation : (node: Node) => Type
>node : Node
>Node : Node
>Type : Type

        typeToString(type: Type, enclosingDeclaration?: Node, flags?: TypeFormatFlags): string;
>typeToString : (type: Type, enclosingDeclaration?: Node, flags?: TypeFormatFlags) => string
>type : Type
>Type : Type
>enclosingDeclaration : Node
>Node : Node
>flags : TypeFormatFlags
>TypeFormatFlags : TypeFormatFlags

        symbolToString(symbol: Symbol, enclosingDeclaration?: Node, meaning?: SymbolFlags): string;
>symbolToString : (symbol: Symbol, enclosingDeclaration?: Node, meaning?: SymbolFlags) => string
>symbol : Symbol
>Symbol : Symbol
>enclosingDeclaration : Node
>Node : Node
>meaning : SymbolFlags
>SymbolFlags : SymbolFlags

        getSymbolDisplayBuilder(): SymbolDisplayBuilder;
>getSymbolDisplayBuilder : () => SymbolDisplayBuilder
>SymbolDisplayBuilder : SymbolDisplayBuilder

        getFullyQualifiedName(symbol: Symbol): string;
>getFullyQualifiedName : (symbol: Symbol) => string
>symbol : Symbol
>Symbol : Symbol

        getAugmentedPropertiesOfType(type: Type): Symbol[];
>getAugmentedPropertiesOfType : (type: Type) => Symbol[]
>type : Type
>Type : Type
>Symbol : Symbol

        getRootSymbols(symbol: Symbol): Symbol[];
>getRootSymbols : (symbol: Symbol) => Symbol[]
>symbol : Symbol
>Symbol : Symbol
>Symbol : Symbol

        getContextualType(node: Expression): Type;
>getContextualType : (node: Expression) => Type
>node : Expression
>Expression : Expression
>Type : Type

        getResolvedSignature(node: CallLikeExpression, candidatesOutArray?: Signature[]): Signature;
>getResolvedSignature : (node: CallExpression | NewExpression | TaggedTemplateExpression, candidatesOutArray?: Signature[]) => Signature
>node : CallExpression | NewExpression | TaggedTemplateExpression
>CallLikeExpression : CallExpression | NewExpression | TaggedTemplateExpression
>candidatesOutArray : Signature[]
>Signature : Signature
>Signature : Signature

        getSignatureFromDeclaration(declaration: SignatureDeclaration): Signature;
>getSignatureFromDeclaration : (declaration: SignatureDeclaration) => Signature
>declaration : SignatureDeclaration
>SignatureDeclaration : SignatureDeclaration
>Signature : Signature

        isImplementationOfOverload(node: FunctionLikeDeclaration): boolean;
>isImplementationOfOverload : (node: FunctionLikeDeclaration) => boolean
>node : FunctionLikeDeclaration
>FunctionLikeDeclaration : FunctionLikeDeclaration

        isUndefinedSymbol(symbol: Symbol): boolean;
>isUndefinedSymbol : (symbol: Symbol) => boolean
>symbol : Symbol
>Symbol : Symbol

        isArgumentsSymbol(symbol: Symbol): boolean;
>isArgumentsSymbol : (symbol: Symbol) => boolean
>symbol : Symbol
>Symbol : Symbol

        getConstantValue(node: EnumMember | PropertyAccessExpression | ElementAccessExpression): number;
>getConstantValue : (node: PropertyAccessExpression | ElementAccessExpression | EnumMember) => number
>node : PropertyAccessExpression | ElementAccessExpression | EnumMember
>EnumMember : EnumMember
>PropertyAccessExpression : PropertyAccessExpression
>ElementAccessExpression : ElementAccessExpression

        isValidPropertyAccess(node: PropertyAccessExpression | QualifiedName, propertyName: string): boolean;
>isValidPropertyAccess : (node: QualifiedName | PropertyAccessExpression, propertyName: string) => boolean
>node : QualifiedName | PropertyAccessExpression
>PropertyAccessExpression : PropertyAccessExpression
>QualifiedName : QualifiedName
>propertyName : string

        getAliasedSymbol(symbol: Symbol): Symbol;
>getAliasedSymbol : (symbol: Symbol) => Symbol
>symbol : Symbol
>Symbol : Symbol
>Symbol : Symbol
    }
    interface SymbolDisplayBuilder {
>SymbolDisplayBuilder : SymbolDisplayBuilder

        buildTypeDisplay(type: Type, writer: SymbolWriter, enclosingDeclaration?: Node, flags?: TypeFormatFlags): void;
>buildTypeDisplay : (type: Type, writer: SymbolWriter, enclosingDeclaration?: Node, flags?: TypeFormatFlags) => void
>type : Type
>Type : Type
>writer : SymbolWriter
>SymbolWriter : SymbolWriter
>enclosingDeclaration : Node
>Node : Node
>flags : TypeFormatFlags
>TypeFormatFlags : TypeFormatFlags

        buildSymbolDisplay(symbol: Symbol, writer: SymbolWriter, enclosingDeclaration?: Node, meaning?: SymbolFlags, flags?: SymbolFormatFlags): void;
>buildSymbolDisplay : (symbol: Symbol, writer: SymbolWriter, enclosingDeclaration?: Node, meaning?: SymbolFlags, flags?: SymbolFormatFlags) => void
>symbol : Symbol
>Symbol : Symbol
>writer : SymbolWriter
>SymbolWriter : SymbolWriter
>enclosingDeclaration : Node
>Node : Node
>meaning : SymbolFlags
>SymbolFlags : SymbolFlags
>flags : SymbolFormatFlags
>SymbolFormatFlags : SymbolFormatFlags

        buildSignatureDisplay(signatures: Signature, writer: SymbolWriter, enclosingDeclaration?: Node, flags?: TypeFormatFlags): void;
>buildSignatureDisplay : (signatures: Signature, writer: SymbolWriter, enclosingDeclaration?: Node, flags?: TypeFormatFlags) => void
>signatures : Signature
>Signature : Signature
>writer : SymbolWriter
>SymbolWriter : SymbolWriter
>enclosingDeclaration : Node
>Node : Node
>flags : TypeFormatFlags
>TypeFormatFlags : TypeFormatFlags

        buildParameterDisplay(parameter: Symbol, writer: SymbolWriter, enclosingDeclaration?: Node, flags?: TypeFormatFlags): void;
>buildParameterDisplay : (parameter: Symbol, writer: SymbolWriter, enclosingDeclaration?: Node, flags?: TypeFormatFlags) => void
>parameter : Symbol
>Symbol : Symbol
>writer : SymbolWriter
>SymbolWriter : SymbolWriter
>enclosingDeclaration : Node
>Node : Node
>flags : TypeFormatFlags
>TypeFormatFlags : TypeFormatFlags

        buildTypeParameterDisplay(tp: TypeParameter, writer: SymbolWriter, enclosingDeclaration?: Node, flags?: TypeFormatFlags): void;
>buildTypeParameterDisplay : (tp: TypeParameter, writer: SymbolWriter, enclosingDeclaration?: Node, flags?: TypeFormatFlags) => void
>tp : TypeParameter
>TypeParameter : TypeParameter
>writer : SymbolWriter
>SymbolWriter : SymbolWriter
>enclosingDeclaration : Node
>Node : Node
>flags : TypeFormatFlags
>TypeFormatFlags : TypeFormatFlags

        buildTypeParameterDisplayFromSymbol(symbol: Symbol, writer: SymbolWriter, enclosingDeclaraiton?: Node, flags?: TypeFormatFlags): void;
>buildTypeParameterDisplayFromSymbol : (symbol: Symbol, writer: SymbolWriter, enclosingDeclaraiton?: Node, flags?: TypeFormatFlags) => void
>symbol : Symbol
>Symbol : Symbol
>writer : SymbolWriter
>SymbolWriter : SymbolWriter
>enclosingDeclaraiton : Node
>Node : Node
>flags : TypeFormatFlags
>TypeFormatFlags : TypeFormatFlags

        buildDisplayForParametersAndDelimiters(parameters: Symbol[], writer: SymbolWriter, enclosingDeclaration?: Node, flags?: TypeFormatFlags): void;
>buildDisplayForParametersAndDelimiters : (parameters: Symbol[], writer: SymbolWriter, enclosingDeclaration?: Node, flags?: TypeFormatFlags) => void
>parameters : Symbol[]
>Symbol : Symbol
>writer : SymbolWriter
>SymbolWriter : SymbolWriter
>enclosingDeclaration : Node
>Node : Node
>flags : TypeFormatFlags
>TypeFormatFlags : TypeFormatFlags

        buildDisplayForTypeParametersAndDelimiters(typeParameters: TypeParameter[], writer: SymbolWriter, enclosingDeclaration?: Node, flags?: TypeFormatFlags): void;
>buildDisplayForTypeParametersAndDelimiters : (typeParameters: TypeParameter[], writer: SymbolWriter, enclosingDeclaration?: Node, flags?: TypeFormatFlags) => void
>typeParameters : TypeParameter[]
>TypeParameter : TypeParameter
>writer : SymbolWriter
>SymbolWriter : SymbolWriter
>enclosingDeclaration : Node
>Node : Node
>flags : TypeFormatFlags
>TypeFormatFlags : TypeFormatFlags

        buildReturnTypeDisplay(signature: Signature, writer: SymbolWriter, enclosingDeclaration?: Node, flags?: TypeFormatFlags): void;
>buildReturnTypeDisplay : (signature: Signature, writer: SymbolWriter, enclosingDeclaration?: Node, flags?: TypeFormatFlags) => void
>signature : Signature
>Signature : Signature
>writer : SymbolWriter
>SymbolWriter : SymbolWriter
>enclosingDeclaration : Node
>Node : Node
>flags : TypeFormatFlags
>TypeFormatFlags : TypeFormatFlags
    }
    interface SymbolWriter {
>SymbolWriter : SymbolWriter

        writeKeyword(text: string): void;
>writeKeyword : (text: string) => void
>text : string

        writeOperator(text: string): void;
>writeOperator : (text: string) => void
>text : string

        writePunctuation(text: string): void;
>writePunctuation : (text: string) => void
>text : string

        writeSpace(text: string): void;
>writeSpace : (text: string) => void
>text : string

        writeStringLiteral(text: string): void;
>writeStringLiteral : (text: string) => void
>text : string

        writeParameter(text: string): void;
>writeParameter : (text: string) => void
>text : string

        writeSymbol(text: string, symbol: Symbol): void;
>writeSymbol : (text: string, symbol: Symbol) => void
>text : string
>symbol : Symbol
>Symbol : Symbol

        writeLine(): void;
>writeLine : () => void

        increaseIndent(): void;
>increaseIndent : () => void

        decreaseIndent(): void;
>decreaseIndent : () => void

        clear(): void;
>clear : () => void

        trackSymbol(symbol: Symbol, enclosingDeclaration?: Node, meaning?: SymbolFlags): void;
>trackSymbol : (symbol: Symbol, enclosingDeclaration?: Node, meaning?: SymbolFlags) => void
>symbol : Symbol
>Symbol : Symbol
>enclosingDeclaration : Node
>Node : Node
>meaning : SymbolFlags
>SymbolFlags : SymbolFlags
    }
    const enum TypeFormatFlags {
>TypeFormatFlags : TypeFormatFlags

        None = 0,
>None : TypeFormatFlags

        WriteArrayAsGenericType = 1,
>WriteArrayAsGenericType : TypeFormatFlags

        UseTypeOfFunction = 2,
>UseTypeOfFunction : TypeFormatFlags

        NoTruncation = 4,
>NoTruncation : TypeFormatFlags

        WriteArrowStyleSignature = 8,
>WriteArrowStyleSignature : TypeFormatFlags

        WriteOwnNameForAnyLike = 16,
>WriteOwnNameForAnyLike : TypeFormatFlags

        WriteTypeArgumentsOfSignature = 32,
>WriteTypeArgumentsOfSignature : TypeFormatFlags

        InElementType = 64,
>InElementType : TypeFormatFlags

        UseFullyQualifiedType = 128,
>UseFullyQualifiedType : TypeFormatFlags
    }
    const enum SymbolFormatFlags {
>SymbolFormatFlags : SymbolFormatFlags

        None = 0,
>None : SymbolFormatFlags

        WriteTypeParametersOrArguments = 1,
>WriteTypeParametersOrArguments : SymbolFormatFlags

        UseOnlyExternalAliasing = 2,
>UseOnlyExternalAliasing : SymbolFormatFlags
    }
    const enum SymbolAccessibility {
>SymbolAccessibility : SymbolAccessibility

        Accessible = 0,
>Accessible : SymbolAccessibility

        NotAccessible = 1,
>NotAccessible : SymbolAccessibility

        CannotBeNamed = 2,
>CannotBeNamed : SymbolAccessibility
    }
    interface SymbolVisibilityResult {
>SymbolVisibilityResult : SymbolVisibilityResult

        accessibility: SymbolAccessibility;
>accessibility : SymbolAccessibility
>SymbolAccessibility : SymbolAccessibility

        aliasesToMakeVisible?: ImportEqualsDeclaration[];
>aliasesToMakeVisible : ImportEqualsDeclaration[]
>ImportEqualsDeclaration : ImportEqualsDeclaration

        errorSymbolName?: string;
>errorSymbolName : string

        errorNode?: Node;
>errorNode : Node
>Node : Node
    }
    interface SymbolAccessiblityResult extends SymbolVisibilityResult {
>SymbolAccessiblityResult : SymbolAccessiblityResult
>SymbolVisibilityResult : SymbolVisibilityResult

        errorModuleName?: string;
>errorModuleName : string
    }
    interface EmitResolver {
>EmitResolver : EmitResolver

        getGeneratedNameForNode(node: ModuleDeclaration | EnumDeclaration | ImportDeclaration | ExportDeclaration): string;
>getGeneratedNameForNode : (node: EnumDeclaration | ExportDeclaration | ModuleDeclaration | ImportDeclaration) => string
>node : EnumDeclaration | ExportDeclaration | ModuleDeclaration | ImportDeclaration
>ModuleDeclaration : ModuleDeclaration
>EnumDeclaration : EnumDeclaration
>ImportDeclaration : ImportDeclaration
>ExportDeclaration : ExportDeclaration

        getExpressionNameSubstitution(node: Identifier): string;
>getExpressionNameSubstitution : (node: Identifier) => string
>node : Identifier
>Identifier : Identifier

        getExportAssignmentName(node: SourceFile): string;
>getExportAssignmentName : (node: SourceFile) => string
>node : SourceFile
>SourceFile : SourceFile

        isReferencedImportDeclaration(node: Node): boolean;
>isReferencedImportDeclaration : (node: Node) => boolean
>node : Node
>Node : Node

        isTopLevelValueImportEqualsWithEntityName(node: ImportEqualsDeclaration): boolean;
>isTopLevelValueImportEqualsWithEntityName : (node: ImportEqualsDeclaration) => boolean
>node : ImportEqualsDeclaration
>ImportEqualsDeclaration : ImportEqualsDeclaration

        getNodeCheckFlags(node: Node): NodeCheckFlags;
>getNodeCheckFlags : (node: Node) => NodeCheckFlags
>node : Node
>Node : Node
>NodeCheckFlags : NodeCheckFlags

        isDeclarationVisible(node: Declaration): boolean;
>isDeclarationVisible : (node: Declaration) => boolean
>node : Declaration
>Declaration : Declaration

        isImplementationOfOverload(node: FunctionLikeDeclaration): boolean;
>isImplementationOfOverload : (node: FunctionLikeDeclaration) => boolean
>node : FunctionLikeDeclaration
>FunctionLikeDeclaration : FunctionLikeDeclaration

        writeTypeOfDeclaration(declaration: AccessorDeclaration | VariableLikeDeclaration, enclosingDeclaration: Node, flags: TypeFormatFlags, writer: SymbolWriter): void;
>writeTypeOfDeclaration : (declaration: VariableLikeDeclaration | AccessorDeclaration, enclosingDeclaration: Node, flags: TypeFormatFlags, writer: SymbolWriter) => void
>declaration : VariableLikeDeclaration | AccessorDeclaration
>AccessorDeclaration : AccessorDeclaration
>VariableLikeDeclaration : VariableLikeDeclaration
>enclosingDeclaration : Node
>Node : Node
>flags : TypeFormatFlags
>TypeFormatFlags : TypeFormatFlags
>writer : SymbolWriter
>SymbolWriter : SymbolWriter

        writeReturnTypeOfSignatureDeclaration(signatureDeclaration: SignatureDeclaration, enclosingDeclaration: Node, flags: TypeFormatFlags, writer: SymbolWriter): void;
>writeReturnTypeOfSignatureDeclaration : (signatureDeclaration: SignatureDeclaration, enclosingDeclaration: Node, flags: TypeFormatFlags, writer: SymbolWriter) => void
>signatureDeclaration : SignatureDeclaration
>SignatureDeclaration : SignatureDeclaration
>enclosingDeclaration : Node
>Node : Node
>flags : TypeFormatFlags
>TypeFormatFlags : TypeFormatFlags
>writer : SymbolWriter
>SymbolWriter : SymbolWriter

        isSymbolAccessible(symbol: Symbol, enclosingDeclaration: Node, meaning: SymbolFlags): SymbolAccessiblityResult;
>isSymbolAccessible : (symbol: Symbol, enclosingDeclaration: Node, meaning: SymbolFlags) => SymbolAccessiblityResult
>symbol : Symbol
>Symbol : Symbol
>enclosingDeclaration : Node
>Node : Node
>meaning : SymbolFlags
>SymbolFlags : SymbolFlags
>SymbolAccessiblityResult : SymbolAccessiblityResult

        isEntityNameVisible(entityName: EntityName, enclosingDeclaration: Node): SymbolVisibilityResult;
>isEntityNameVisible : (entityName: Identifier | QualifiedName, enclosingDeclaration: Node) => SymbolVisibilityResult
>entityName : Identifier | QualifiedName
>EntityName : Identifier | QualifiedName
>enclosingDeclaration : Node
>Node : Node
>SymbolVisibilityResult : SymbolVisibilityResult

        getConstantValue(node: EnumMember | PropertyAccessExpression | ElementAccessExpression): number;
>getConstantValue : (node: PropertyAccessExpression | ElementAccessExpression | EnumMember) => number
>node : PropertyAccessExpression | ElementAccessExpression | EnumMember
>EnumMember : EnumMember
>PropertyAccessExpression : PropertyAccessExpression
>ElementAccessExpression : ElementAccessExpression

        isUnknownIdentifier(location: Node, name: string): boolean;
>isUnknownIdentifier : (location: Node, name: string) => boolean
>location : Node
>Node : Node
>name : string
    }
    const enum SymbolFlags {
>SymbolFlags : SymbolFlags

        FunctionScopedVariable = 1,
>FunctionScopedVariable : SymbolFlags

        BlockScopedVariable = 2,
>BlockScopedVariable : SymbolFlags

        Property = 4,
>Property : SymbolFlags

        EnumMember = 8,
>EnumMember : SymbolFlags

        Function = 16,
>Function : SymbolFlags

        Class = 32,
>Class : SymbolFlags

        Interface = 64,
>Interface : SymbolFlags

        ConstEnum = 128,
>ConstEnum : SymbolFlags

        RegularEnum = 256,
>RegularEnum : SymbolFlags

        ValueModule = 512,
>ValueModule : SymbolFlags

        NamespaceModule = 1024,
>NamespaceModule : SymbolFlags

        TypeLiteral = 2048,
>TypeLiteral : SymbolFlags

        ObjectLiteral = 4096,
>ObjectLiteral : SymbolFlags

        Method = 8192,
>Method : SymbolFlags

        Constructor = 16384,
>Constructor : SymbolFlags

        GetAccessor = 32768,
>GetAccessor : SymbolFlags

        SetAccessor = 65536,
>SetAccessor : SymbolFlags

        Signature = 131072,
>Signature : SymbolFlags

        TypeParameter = 262144,
>TypeParameter : SymbolFlags

        TypeAlias = 524288,
>TypeAlias : SymbolFlags

        ExportValue = 1048576,
>ExportValue : SymbolFlags

        ExportType = 2097152,
>ExportType : SymbolFlags

        ExportNamespace = 4194304,
>ExportNamespace : SymbolFlags

        Import = 8388608,
>Import : SymbolFlags

        Instantiated = 16777216,
>Instantiated : SymbolFlags

        Merged = 33554432,
>Merged : SymbolFlags

        Transient = 67108864,
>Transient : SymbolFlags

        Prototype = 134217728,
>Prototype : SymbolFlags

        UnionProperty = 268435456,
>UnionProperty : SymbolFlags

        Optional = 536870912,
>Optional : SymbolFlags

        Enum = 384,
>Enum : SymbolFlags

        Variable = 3,
>Variable : SymbolFlags

        Value = 107455,
>Value : SymbolFlags

        Type = 793056,
>Type : SymbolFlags

        Namespace = 1536,
>Namespace : SymbolFlags

        Module = 1536,
>Module : SymbolFlags

        Accessor = 98304,
>Accessor : SymbolFlags

        FunctionScopedVariableExcludes = 107454,
>FunctionScopedVariableExcludes : SymbolFlags

        BlockScopedVariableExcludes = 107455,
>BlockScopedVariableExcludes : SymbolFlags

        ParameterExcludes = 107455,
>ParameterExcludes : SymbolFlags

        PropertyExcludes = 107455,
>PropertyExcludes : SymbolFlags

        EnumMemberExcludes = 107455,
>EnumMemberExcludes : SymbolFlags

        FunctionExcludes = 106927,
>FunctionExcludes : SymbolFlags

        ClassExcludes = 899583,
>ClassExcludes : SymbolFlags

        InterfaceExcludes = 792992,
>InterfaceExcludes : SymbolFlags

        RegularEnumExcludes = 899327,
>RegularEnumExcludes : SymbolFlags

        ConstEnumExcludes = 899967,
>ConstEnumExcludes : SymbolFlags

        ValueModuleExcludes = 106639,
>ValueModuleExcludes : SymbolFlags

        NamespaceModuleExcludes = 0,
>NamespaceModuleExcludes : SymbolFlags

        MethodExcludes = 99263,
>MethodExcludes : SymbolFlags

        GetAccessorExcludes = 41919,
>GetAccessorExcludes : SymbolFlags

        SetAccessorExcludes = 74687,
>SetAccessorExcludes : SymbolFlags

        TypeParameterExcludes = 530912,
>TypeParameterExcludes : SymbolFlags

        TypeAliasExcludes = 793056,
>TypeAliasExcludes : SymbolFlags

        ImportExcludes = 8388608,
>ImportExcludes : SymbolFlags

        ModuleMember = 8914931,
>ModuleMember : SymbolFlags

        ExportHasLocal = 944,
>ExportHasLocal : SymbolFlags

        HasLocals = 255504,
>HasLocals : SymbolFlags

        HasExports = 1952,
>HasExports : SymbolFlags

        HasMembers = 6240,
>HasMembers : SymbolFlags

        IsContainer = 262128,
>IsContainer : SymbolFlags

        PropertyOrAccessor = 98308,
>PropertyOrAccessor : SymbolFlags

        Export = 7340032,
>Export : SymbolFlags
    }
    interface Symbol {
>Symbol : Symbol

        flags: SymbolFlags;
>flags : SymbolFlags
>SymbolFlags : SymbolFlags

        name: string;
>name : string

        id?: number;
>id : number

        mergeId?: number;
>mergeId : number

        declarations?: Declaration[];
>declarations : Declaration[]
>Declaration : Declaration

        parent?: Symbol;
>parent : Symbol
>Symbol : Symbol

        members?: SymbolTable;
>members : SymbolTable
>SymbolTable : SymbolTable

        exports?: SymbolTable;
>exports : SymbolTable
>SymbolTable : SymbolTable

        exportSymbol?: Symbol;
>exportSymbol : Symbol
>Symbol : Symbol

        valueDeclaration?: Declaration;
>valueDeclaration : Declaration
>Declaration : Declaration

        constEnumOnlyModule?: boolean;
>constEnumOnlyModule : boolean
    }
    interface SymbolLinks {
>SymbolLinks : SymbolLinks

        target?: Symbol;
>target : Symbol
>Symbol : Symbol

        type?: Type;
>type : Type
>Type : Type

        declaredType?: Type;
>declaredType : Type
>Type : Type

        mapper?: TypeMapper;
>mapper : TypeMapper
>TypeMapper : TypeMapper

        referenced?: boolean;
>referenced : boolean

        exportAssignmentChecked?: boolean;
>exportAssignmentChecked : boolean

        exportAssignmentSymbol?: Symbol;
>exportAssignmentSymbol : Symbol
>Symbol : Symbol

        unionType?: UnionType;
>unionType : UnionType
>UnionType : UnionType

        resolvedExports?: SymbolTable;
>resolvedExports : SymbolTable
>SymbolTable : SymbolTable
    }
    interface TransientSymbol extends Symbol, SymbolLinks {
>TransientSymbol : TransientSymbol
>Symbol : Symbol
>SymbolLinks : SymbolLinks
    }
    interface SymbolTable {
>SymbolTable : SymbolTable

        [index: string]: Symbol;
>index : string
>Symbol : Symbol
    }
    const enum NodeCheckFlags {
>NodeCheckFlags : NodeCheckFlags

        TypeChecked = 1,
>TypeChecked : NodeCheckFlags

        LexicalThis = 2,
>LexicalThis : NodeCheckFlags

        CaptureThis = 4,
>CaptureThis : NodeCheckFlags

        EmitExtends = 8,
>EmitExtends : NodeCheckFlags

        SuperInstance = 16,
>SuperInstance : NodeCheckFlags

        SuperStatic = 32,
>SuperStatic : NodeCheckFlags

        ContextChecked = 64,
>ContextChecked : NodeCheckFlags

        EnumValuesComputed = 128,
>EnumValuesComputed : NodeCheckFlags
    }
    interface NodeLinks {
>NodeLinks : NodeLinks

        resolvedType?: Type;
>resolvedType : Type
>Type : Type

        resolvedSignature?: Signature;
>resolvedSignature : Signature
>Signature : Signature

        resolvedSymbol?: Symbol;
>resolvedSymbol : Symbol
>Symbol : Symbol

        flags?: NodeCheckFlags;
>flags : NodeCheckFlags
>NodeCheckFlags : NodeCheckFlags

        enumMemberValue?: number;
>enumMemberValue : number

        isIllegalTypeReferenceInConstraint?: boolean;
>isIllegalTypeReferenceInConstraint : boolean

        isVisible?: boolean;
>isVisible : boolean

        generatedName?: string;
>generatedName : string

        generatedNames?: Map<string>;
>generatedNames : Map<string>
>Map : Map<T>

        assignmentChecks?: Map<boolean>;
>assignmentChecks : Map<boolean>
>Map : Map<T>

        hasReportedStatementInAmbientContext?: boolean;
>hasReportedStatementInAmbientContext : boolean

        importOnRightSide?: Symbol;
>importOnRightSide : Symbol
>Symbol : Symbol
    }
    const enum TypeFlags {
>TypeFlags : TypeFlags

        Any = 1,
>Any : TypeFlags

        String = 2,
>String : TypeFlags

        Number = 4,
>Number : TypeFlags

        Boolean = 8,
>Boolean : TypeFlags

        Void = 16,
>Void : TypeFlags

        Undefined = 32,
>Undefined : TypeFlags

        Null = 64,
>Null : TypeFlags

        Enum = 128,
>Enum : TypeFlags

        StringLiteral = 256,
>StringLiteral : TypeFlags

        TypeParameter = 512,
>TypeParameter : TypeFlags

        Class = 1024,
>Class : TypeFlags

        Interface = 2048,
>Interface : TypeFlags

        Reference = 4096,
>Reference : TypeFlags

        Tuple = 8192,
>Tuple : TypeFlags

        Union = 16384,
>Union : TypeFlags

        Anonymous = 32768,
>Anonymous : TypeFlags

        FromSignature = 65536,
>FromSignature : TypeFlags

        ObjectLiteral = 131072,
>ObjectLiteral : TypeFlags

        ContainsUndefinedOrNull = 262144,
>ContainsUndefinedOrNull : TypeFlags

        ContainsObjectLiteral = 524288,
>ContainsObjectLiteral : TypeFlags

        ESSymbol = 1048576,
>ESSymbol : TypeFlags

        Intrinsic = 1048703,
>Intrinsic : TypeFlags

        Primitive = 1049086,
>Primitive : TypeFlags

        StringLike = 258,
>StringLike : TypeFlags

        NumberLike = 132,
>NumberLike : TypeFlags

        ObjectType = 48128,
>ObjectType : TypeFlags

        RequiresWidening = 786432,
>RequiresWidening : TypeFlags
    }
    interface Type {
>Type : Type

        flags: TypeFlags;
>flags : TypeFlags
>TypeFlags : TypeFlags

        id: number;
>id : number

        symbol?: Symbol;
>symbol : Symbol
>Symbol : Symbol
    }
    interface IntrinsicType extends Type {
>IntrinsicType : IntrinsicType
>Type : Type

        intrinsicName: string;
>intrinsicName : string
    }
    interface StringLiteralType extends Type {
>StringLiteralType : StringLiteralType
>Type : Type

        text: string;
>text : string
    }
    interface ObjectType extends Type {
>ObjectType : ObjectType
>Type : Type
    }
    interface InterfaceType extends ObjectType {
>InterfaceType : InterfaceType
>ObjectType : ObjectType

        typeParameters: TypeParameter[];
>typeParameters : TypeParameter[]
>TypeParameter : TypeParameter

        baseTypes: ObjectType[];
>baseTypes : ObjectType[]
>ObjectType : ObjectType

        declaredProperties: Symbol[];
>declaredProperties : Symbol[]
>Symbol : Symbol

        declaredCallSignatures: Signature[];
>declaredCallSignatures : Signature[]
>Signature : Signature

        declaredConstructSignatures: Signature[];
>declaredConstructSignatures : Signature[]
>Signature : Signature

        declaredStringIndexType: Type;
>declaredStringIndexType : Type
>Type : Type

        declaredNumberIndexType: Type;
>declaredNumberIndexType : Type
>Type : Type
    }
    interface TypeReference extends ObjectType {
>TypeReference : TypeReference
>ObjectType : ObjectType

        target: GenericType;
>target : GenericType
>GenericType : GenericType

        typeArguments: Type[];
>typeArguments : Type[]
>Type : Type
    }
    interface GenericType extends InterfaceType, TypeReference {
>GenericType : GenericType
>InterfaceType : InterfaceType
>TypeReference : TypeReference

        instantiations: Map<TypeReference>;
>instantiations : Map<TypeReference>
>Map : Map<T>
>TypeReference : TypeReference
    }
    interface TupleType extends ObjectType {
>TupleType : TupleType
>ObjectType : ObjectType

        elementTypes: Type[];
>elementTypes : Type[]
>Type : Type

        baseArrayType: TypeReference;
>baseArrayType : TypeReference
>TypeReference : TypeReference
    }
    interface UnionType extends Type {
>UnionType : UnionType
>Type : Type

        types: Type[];
>types : Type[]
>Type : Type

        resolvedProperties: SymbolTable;
>resolvedProperties : SymbolTable
>SymbolTable : SymbolTable
    }
    interface ResolvedType extends ObjectType, UnionType {
>ResolvedType : ResolvedType
>ObjectType : ObjectType
>UnionType : UnionType

        members: SymbolTable;
>members : SymbolTable
>SymbolTable : SymbolTable

        properties: Symbol[];
>properties : Symbol[]
>Symbol : Symbol

        callSignatures: Signature[];
>callSignatures : Signature[]
>Signature : Signature

        constructSignatures: Signature[];
>constructSignatures : Signature[]
>Signature : Signature

        stringIndexType: Type;
>stringIndexType : Type
>Type : Type

        numberIndexType: Type;
>numberIndexType : Type
>Type : Type
    }
    interface TypeParameter extends Type {
>TypeParameter : TypeParameter
>Type : Type

        constraint: Type;
>constraint : Type
>Type : Type

        target?: TypeParameter;
>target : TypeParameter
>TypeParameter : TypeParameter

        mapper?: TypeMapper;
>mapper : TypeMapper
>TypeMapper : TypeMapper
    }
    const enum SignatureKind {
>SignatureKind : SignatureKind

        Call = 0,
>Call : SignatureKind

        Construct = 1,
>Construct : SignatureKind
    }
    interface Signature {
>Signature : Signature

        declaration: SignatureDeclaration;
>declaration : SignatureDeclaration
>SignatureDeclaration : SignatureDeclaration

        typeParameters: TypeParameter[];
>typeParameters : TypeParameter[]
>TypeParameter : TypeParameter

        parameters: Symbol[];
>parameters : Symbol[]
>Symbol : Symbol

        resolvedReturnType: Type;
>resolvedReturnType : Type
>Type : Type

        minArgumentCount: number;
>minArgumentCount : number

        hasRestParameter: boolean;
>hasRestParameter : boolean

        hasStringLiterals: boolean;
>hasStringLiterals : boolean

        target?: Signature;
>target : Signature
>Signature : Signature

        mapper?: TypeMapper;
>mapper : TypeMapper
>TypeMapper : TypeMapper

        unionSignatures?: Signature[];
>unionSignatures : Signature[]
>Signature : Signature

        erasedSignatureCache?: Signature;
>erasedSignatureCache : Signature
>Signature : Signature

        isolatedSignatureType?: ObjectType;
>isolatedSignatureType : ObjectType
>ObjectType : ObjectType
    }
    const enum IndexKind {
>IndexKind : IndexKind

        String = 0,
>String : IndexKind

        Number = 1,
>Number : IndexKind
    }
    interface TypeMapper {
>TypeMapper : TypeMapper

        (t: Type): Type;
>t : Type
>Type : Type
>Type : Type
    }
    interface TypeInferences {
>TypeInferences : TypeInferences

        primary: Type[];
>primary : Type[]
>Type : Type

        secondary: Type[];
>secondary : Type[]
>Type : Type
    }
    interface InferenceContext {
>InferenceContext : InferenceContext

        typeParameters: TypeParameter[];
>typeParameters : TypeParameter[]
>TypeParameter : TypeParameter

        inferUnionTypes: boolean;
>inferUnionTypes : boolean

        inferences: TypeInferences[];
>inferences : TypeInferences[]
>TypeInferences : TypeInferences

        inferredTypes: Type[];
>inferredTypes : Type[]
>Type : Type

        failedTypeParameterIndex?: number;
>failedTypeParameterIndex : number
    }
    interface DiagnosticMessage {
>DiagnosticMessage : DiagnosticMessage

        key: string;
>key : string

        category: DiagnosticCategory;
>category : DiagnosticCategory
>DiagnosticCategory : DiagnosticCategory

        code: number;
>code : number
    }
    interface DiagnosticMessageChain {
>DiagnosticMessageChain : DiagnosticMessageChain

        messageText: string;
>messageText : string

        category: DiagnosticCategory;
>category : DiagnosticCategory
>DiagnosticCategory : DiagnosticCategory

        code: number;
>code : number

        next?: DiagnosticMessageChain;
>next : DiagnosticMessageChain
>DiagnosticMessageChain : DiagnosticMessageChain
    }
    interface Diagnostic {
>Diagnostic : Diagnostic

        file: SourceFile;
>file : SourceFile
>SourceFile : SourceFile

        start: number;
>start : number

        length: number;
>length : number

        messageText: string | DiagnosticMessageChain;
>messageText : string | DiagnosticMessageChain
>DiagnosticMessageChain : DiagnosticMessageChain

        category: DiagnosticCategory;
>category : DiagnosticCategory
>DiagnosticCategory : DiagnosticCategory

        code: number;
>code : number
    }
    enum DiagnosticCategory {
>DiagnosticCategory : DiagnosticCategory

        Warning = 0,
>Warning : DiagnosticCategory

        Error = 1,
>Error : DiagnosticCategory

        Message = 2,
>Message : DiagnosticCategory
    }
    interface CompilerOptions {
>CompilerOptions : CompilerOptions

        allowNonTsExtensions?: boolean;
>allowNonTsExtensions : boolean

        charset?: string;
>charset : string

        codepage?: number;
>codepage : number

        declaration?: boolean;
>declaration : boolean

        diagnostics?: boolean;
>diagnostics : boolean

        emitBOM?: boolean;
>emitBOM : boolean

        help?: boolean;
>help : boolean

        listFiles?: boolean;
>listFiles : boolean

        locale?: string;
>locale : string

        mapRoot?: string;
>mapRoot : string

        module?: ModuleKind;
>module : ModuleKind
>ModuleKind : ModuleKind

        noEmit?: boolean;
>noEmit : boolean

        noEmitOnError?: boolean;
>noEmitOnError : boolean

        noErrorTruncation?: boolean;
>noErrorTruncation : boolean

        noImplicitAny?: boolean;
>noImplicitAny : boolean

        noLib?: boolean;
>noLib : boolean

        noLibCheck?: boolean;
>noLibCheck : boolean

        noResolve?: boolean;
>noResolve : boolean

        out?: string;
>out : string

        outDir?: string;
>outDir : string

        preserveConstEnums?: boolean;
>preserveConstEnums : boolean

        project?: string;
>project : string

        removeComments?: boolean;
>removeComments : boolean

        sourceMap?: boolean;
>sourceMap : boolean

        sourceRoot?: string;
>sourceRoot : string

        suppressImplicitAnyIndexErrors?: boolean;
>suppressImplicitAnyIndexErrors : boolean

        target?: ScriptTarget;
>target : ScriptTarget
>ScriptTarget : ScriptTarget

        version?: boolean;
>version : boolean

        watch?: boolean;
>watch : boolean

        stripInternal?: boolean;
>stripInternal : boolean

        [option: string]: string | number | boolean;
>option : string
    }
    const enum ModuleKind {
>ModuleKind : ModuleKind

        None = 0,
>None : ModuleKind

        CommonJS = 1,
>CommonJS : ModuleKind

        AMD = 2,
>AMD : ModuleKind
    }
    interface LineAndCharacter {
>LineAndCharacter : LineAndCharacter

        line: number;
>line : number

        character: number;
>character : number
    }
    const enum ScriptTarget {
>ScriptTarget : ScriptTarget

        ES3 = 0,
>ES3 : ScriptTarget

        ES5 = 1,
>ES5 : ScriptTarget

        ES6 = 2,
>ES6 : ScriptTarget

        Latest = 2,
>Latest : ScriptTarget
    }
    interface ParsedCommandLine {
>ParsedCommandLine : ParsedCommandLine

        options: CompilerOptions;
>options : CompilerOptions
>CompilerOptions : CompilerOptions

        fileNames: string[];
>fileNames : string[]

        errors: Diagnostic[];
>errors : Diagnostic[]
>Diagnostic : Diagnostic
    }
    interface CommandLineOption {
>CommandLineOption : CommandLineOption

        name: string;
>name : string

        type: string | Map<number>;
>type : string | Map<number>
>Map : Map<T>

        isFilePath?: boolean;
>isFilePath : boolean

        shortName?: string;
>shortName : string

        description?: DiagnosticMessage;
>description : DiagnosticMessage
>DiagnosticMessage : DiagnosticMessage

        paramType?: DiagnosticMessage;
>paramType : DiagnosticMessage
>DiagnosticMessage : DiagnosticMessage

        error?: DiagnosticMessage;
>error : DiagnosticMessage
>DiagnosticMessage : DiagnosticMessage

        experimental?: boolean;
>experimental : boolean
    }
    const enum CharacterCodes {
>CharacterCodes : CharacterCodes

        nullCharacter = 0,
>nullCharacter : CharacterCodes

        maxAsciiCharacter = 127,
>maxAsciiCharacter : CharacterCodes

        lineFeed = 10,
>lineFeed : CharacterCodes

        carriageReturn = 13,
>carriageReturn : CharacterCodes

        lineSeparator = 8232,
>lineSeparator : CharacterCodes

        paragraphSeparator = 8233,
>paragraphSeparator : CharacterCodes

        nextLine = 133,
>nextLine : CharacterCodes

        space = 32,
>space : CharacterCodes

        nonBreakingSpace = 160,
>nonBreakingSpace : CharacterCodes

        enQuad = 8192,
>enQuad : CharacterCodes

        emQuad = 8193,
>emQuad : CharacterCodes

        enSpace = 8194,
>enSpace : CharacterCodes

        emSpace = 8195,
>emSpace : CharacterCodes

        threePerEmSpace = 8196,
>threePerEmSpace : CharacterCodes

        fourPerEmSpace = 8197,
>fourPerEmSpace : CharacterCodes

        sixPerEmSpace = 8198,
>sixPerEmSpace : CharacterCodes

        figureSpace = 8199,
>figureSpace : CharacterCodes

        punctuationSpace = 8200,
>punctuationSpace : CharacterCodes

        thinSpace = 8201,
>thinSpace : CharacterCodes

        hairSpace = 8202,
>hairSpace : CharacterCodes

        zeroWidthSpace = 8203,
>zeroWidthSpace : CharacterCodes

        narrowNoBreakSpace = 8239,
>narrowNoBreakSpace : CharacterCodes

        ideographicSpace = 12288,
>ideographicSpace : CharacterCodes

        mathematicalSpace = 8287,
>mathematicalSpace : CharacterCodes

        ogham = 5760,
>ogham : CharacterCodes

        _ = 95,
>_ : CharacterCodes

        $ = 36,
>$ : CharacterCodes

        _0 = 48,
>_0 : CharacterCodes

        _1 = 49,
>_1 : CharacterCodes

        _2 = 50,
>_2 : CharacterCodes

        _3 = 51,
>_3 : CharacterCodes

        _4 = 52,
>_4 : CharacterCodes

        _5 = 53,
>_5 : CharacterCodes

        _6 = 54,
>_6 : CharacterCodes

        _7 = 55,
>_7 : CharacterCodes

        _8 = 56,
>_8 : CharacterCodes

        _9 = 57,
>_9 : CharacterCodes

        a = 97,
>a : CharacterCodes

        b = 98,
>b : CharacterCodes

        c = 99,
>c : CharacterCodes

        d = 100,
>d : CharacterCodes

        e = 101,
>e : CharacterCodes

        f = 102,
>f : CharacterCodes

        g = 103,
>g : CharacterCodes

        h = 104,
>h : CharacterCodes

        i = 105,
>i : CharacterCodes

        j = 106,
>j : CharacterCodes

        k = 107,
>k : CharacterCodes

        l = 108,
>l : CharacterCodes

        m = 109,
>m : CharacterCodes

        n = 110,
>n : CharacterCodes

        o = 111,
>o : CharacterCodes

        p = 112,
>p : CharacterCodes

        q = 113,
>q : CharacterCodes

        r = 114,
>r : CharacterCodes

        s = 115,
>s : CharacterCodes

        t = 116,
>t : CharacterCodes

        u = 117,
>u : CharacterCodes

        v = 118,
>v : CharacterCodes

        w = 119,
>w : CharacterCodes

        x = 120,
>x : CharacterCodes

        y = 121,
>y : CharacterCodes

        z = 122,
>z : CharacterCodes

        A = 65,
>A : CharacterCodes

        B = 66,
>B : CharacterCodes

        C = 67,
>C : CharacterCodes

        D = 68,
>D : CharacterCodes

        E = 69,
>E : CharacterCodes

        F = 70,
>F : CharacterCodes

        G = 71,
>G : CharacterCodes

        H = 72,
>H : CharacterCodes

        I = 73,
>I : CharacterCodes

        J = 74,
>J : CharacterCodes

        K = 75,
>K : CharacterCodes

        L = 76,
>L : CharacterCodes

        M = 77,
>M : CharacterCodes

        N = 78,
>N : CharacterCodes

        O = 79,
>O : CharacterCodes

        P = 80,
>P : CharacterCodes

        Q = 81,
>Q : CharacterCodes

        R = 82,
>R : CharacterCodes

        S = 83,
>S : CharacterCodes

        T = 84,
>T : CharacterCodes

        U = 85,
>U : CharacterCodes

        V = 86,
>V : CharacterCodes

        W = 87,
>W : CharacterCodes

        X = 88,
>X : CharacterCodes

        Y = 89,
>Y : CharacterCodes

        Z = 90,
>Z : CharacterCodes

        ampersand = 38,
>ampersand : CharacterCodes

        asterisk = 42,
>asterisk : CharacterCodes

        at = 64,
>at : CharacterCodes

        backslash = 92,
>backslash : CharacterCodes

        backtick = 96,
>backtick : CharacterCodes

        bar = 124,
>bar : CharacterCodes

        caret = 94,
>caret : CharacterCodes

        closeBrace = 125,
>closeBrace : CharacterCodes

        closeBracket = 93,
>closeBracket : CharacterCodes

        closeParen = 41,
>closeParen : CharacterCodes

        colon = 58,
>colon : CharacterCodes

        comma = 44,
>comma : CharacterCodes

        dot = 46,
>dot : CharacterCodes

        doubleQuote = 34,
>doubleQuote : CharacterCodes

        equals = 61,
>equals : CharacterCodes

        exclamation = 33,
>exclamation : CharacterCodes

        greaterThan = 62,
>greaterThan : CharacterCodes

        hash = 35,
>hash : CharacterCodes

        lessThan = 60,
>lessThan : CharacterCodes

        minus = 45,
>minus : CharacterCodes

        openBrace = 123,
>openBrace : CharacterCodes

        openBracket = 91,
>openBracket : CharacterCodes

        openParen = 40,
>openParen : CharacterCodes

        percent = 37,
>percent : CharacterCodes

        plus = 43,
>plus : CharacterCodes

        question = 63,
>question : CharacterCodes

        semicolon = 59,
>semicolon : CharacterCodes

        singleQuote = 39,
>singleQuote : CharacterCodes

        slash = 47,
>slash : CharacterCodes

        tilde = 126,
>tilde : CharacterCodes

        backspace = 8,
>backspace : CharacterCodes

        formFeed = 12,
>formFeed : CharacterCodes

        byteOrderMark = 65279,
>byteOrderMark : CharacterCodes

        tab = 9,
>tab : CharacterCodes

        verticalTab = 11,
>verticalTab : CharacterCodes
    }
    interface CancellationToken {
>CancellationToken : CancellationToken

        isCancellationRequested(): boolean;
>isCancellationRequested : () => boolean
    }
    interface CompilerHost {
>CompilerHost : CompilerHost

        getSourceFile(fileName: string, languageVersion: ScriptTarget, onError?: (message: string) => void): SourceFile;
>getSourceFile : (fileName: string, languageVersion: ScriptTarget, onError?: (message: string) => void) => SourceFile
>fileName : string
>languageVersion : ScriptTarget
>ScriptTarget : ScriptTarget
>onError : (message: string) => void
>message : string
>SourceFile : SourceFile

        getDefaultLibFileName(options: CompilerOptions): string;
>getDefaultLibFileName : (options: CompilerOptions) => string
>options : CompilerOptions
>CompilerOptions : CompilerOptions

        getCancellationToken?(): CancellationToken;
>getCancellationToken : () => CancellationToken
>CancellationToken : CancellationToken

        writeFile: WriteFileCallback;
>writeFile : WriteFileCallback
>WriteFileCallback : WriteFileCallback

        getCurrentDirectory(): string;
>getCurrentDirectory : () => string

        getCanonicalFileName(fileName: string): string;
>getCanonicalFileName : (fileName: string) => string
>fileName : string

        useCaseSensitiveFileNames(): boolean;
>useCaseSensitiveFileNames : () => boolean

        getNewLine(): string;
>getNewLine : () => string
    }
    interface TextSpan {
>TextSpan : TextSpan

        start: number;
>start : number

        length: number;
>length : number
    }
    interface TextChangeRange {
>TextChangeRange : TextChangeRange

        span: TextSpan;
>span : TextSpan
>TextSpan : TextSpan

        newLength: number;
>newLength : number
    }
}
declare module "typescript" {
    interface ErrorCallback {
>ErrorCallback : ErrorCallback

        (message: DiagnosticMessage, length: number): void;
>message : DiagnosticMessage
>DiagnosticMessage : DiagnosticMessage
>length : number
    }
    interface Scanner {
>Scanner : Scanner

        getStartPos(): number;
>getStartPos : () => number

        getToken(): SyntaxKind;
>getToken : () => SyntaxKind
>SyntaxKind : SyntaxKind

        getTextPos(): number;
>getTextPos : () => number

        getTokenPos(): number;
>getTokenPos : () => number

        getTokenText(): string;
>getTokenText : () => string

        getTokenValue(): string;
>getTokenValue : () => string

        hasPrecedingLineBreak(): boolean;
>hasPrecedingLineBreak : () => boolean

        isIdentifier(): boolean;
>isIdentifier : () => boolean

        isReservedWord(): boolean;
>isReservedWord : () => boolean

        isUnterminated(): boolean;
>isUnterminated : () => boolean

        reScanGreaterToken(): SyntaxKind;
>reScanGreaterToken : () => SyntaxKind
>SyntaxKind : SyntaxKind

        reScanSlashToken(): SyntaxKind;
>reScanSlashToken : () => SyntaxKind
>SyntaxKind : SyntaxKind

        reScanTemplateToken(): SyntaxKind;
>reScanTemplateToken : () => SyntaxKind
>SyntaxKind : SyntaxKind

        scan(): SyntaxKind;
>scan : () => SyntaxKind
>SyntaxKind : SyntaxKind

        setText(text: string): void;
>setText : (text: string) => void
>text : string

        setTextPos(textPos: number): void;
>setTextPos : (textPos: number) => void
>textPos : number

        lookAhead<T>(callback: () => T): T;
>lookAhead : <T>(callback: () => T) => T
>T : T
>callback : () => T
>T : T
>T : T

        tryScan<T>(callback: () => T): T;
>tryScan : <T>(callback: () => T) => T
>T : T
>callback : () => T
>T : T
>T : T
    }
    function tokenToString(t: SyntaxKind): string;
>tokenToString : (t: SyntaxKind) => string
>t : SyntaxKind
>SyntaxKind : SyntaxKind

    function computeLineStarts(text: string): number[];
>computeLineStarts : (text: string) => number[]
>text : string

    function getPositionOfLineAndCharacter(sourceFile: SourceFile, line: number, character: number): number;
>getPositionOfLineAndCharacter : (sourceFile: SourceFile, line: number, character: number) => number
>sourceFile : SourceFile
>SourceFile : SourceFile
>line : number
>character : number

    function computePositionOfLineAndCharacter(lineStarts: number[], line: number, character: number): number;
>computePositionOfLineAndCharacter : (lineStarts: number[], line: number, character: number) => number
>lineStarts : number[]
>line : number
>character : number

    function getLineStarts(sourceFile: SourceFile): number[];
>getLineStarts : (sourceFile: SourceFile) => number[]
>sourceFile : SourceFile
>SourceFile : SourceFile

    function computeLineAndCharacterOfPosition(lineStarts: number[], position: number): {
>computeLineAndCharacterOfPosition : (lineStarts: number[], position: number) => { line: number; character: number; }
>lineStarts : number[]
>position : number

        line: number;
>line : number

        character: number;
>character : number

    };
    function getLineAndCharacterOfPosition(sourceFile: SourceFile, position: number): LineAndCharacter;
>getLineAndCharacterOfPosition : (sourceFile: SourceFile, position: number) => LineAndCharacter
>sourceFile : SourceFile
>SourceFile : SourceFile
>position : number
>LineAndCharacter : LineAndCharacter

    function isWhiteSpace(ch: number): boolean;
>isWhiteSpace : (ch: number) => boolean
>ch : number

    function isLineBreak(ch: number): boolean;
>isLineBreak : (ch: number) => boolean
>ch : number

    function isOctalDigit(ch: number): boolean;
>isOctalDigit : (ch: number) => boolean
>ch : number

    function skipTrivia(text: string, pos: number, stopAfterLineBreak?: boolean): number;
>skipTrivia : (text: string, pos: number, stopAfterLineBreak?: boolean) => number
>text : string
>pos : number
>stopAfterLineBreak : boolean

    function getLeadingCommentRanges(text: string, pos: number): CommentRange[];
>getLeadingCommentRanges : (text: string, pos: number) => CommentRange[]
>text : string
>pos : number
>CommentRange : CommentRange

    function getTrailingCommentRanges(text: string, pos: number): CommentRange[];
>getTrailingCommentRanges : (text: string, pos: number) => CommentRange[]
>text : string
>pos : number
>CommentRange : CommentRange

    function isIdentifierStart(ch: number, languageVersion: ScriptTarget): boolean;
>isIdentifierStart : (ch: number, languageVersion: ScriptTarget) => boolean
>ch : number
>languageVersion : ScriptTarget
>ScriptTarget : ScriptTarget

    function isIdentifierPart(ch: number, languageVersion: ScriptTarget): boolean;
>isIdentifierPart : (ch: number, languageVersion: ScriptTarget) => boolean
>ch : number
>languageVersion : ScriptTarget
>ScriptTarget : ScriptTarget

    function createScanner(languageVersion: ScriptTarget, skipTrivia: boolean, text?: string, onError?: ErrorCallback): Scanner;
>createScanner : (languageVersion: ScriptTarget, skipTrivia: boolean, text?: string, onError?: ErrorCallback) => Scanner
>languageVersion : ScriptTarget
>ScriptTarget : ScriptTarget
>skipTrivia : boolean
>text : string
>onError : ErrorCallback
>ErrorCallback : ErrorCallback
>Scanner : Scanner
}
declare module "typescript" {
    function getNodeConstructor(kind: SyntaxKind): new () => Node;
>getNodeConstructor : (kind: SyntaxKind) => new () => Node
>kind : SyntaxKind
>SyntaxKind : SyntaxKind
>Node : Node

    function createNode(kind: SyntaxKind): Node;
>createNode : (kind: SyntaxKind) => Node
>kind : SyntaxKind
>SyntaxKind : SyntaxKind
>Node : Node

    function forEachChild<T>(node: Node, cbNode: (node: Node) => T, cbNodeArray?: (nodes: Node[]) => T): T;
>forEachChild : <T>(node: Node, cbNode: (node: Node) => T, cbNodeArray?: (nodes: Node[]) => T) => T
>T : T
>node : Node
>Node : Node
>cbNode : (node: Node) => T
>node : Node
>Node : Node
>T : T
>cbNodeArray : (nodes: Node[]) => T
>nodes : Node[]
>Node : Node
>T : T
>T : T

    function modifierToFlag(token: SyntaxKind): NodeFlags;
>modifierToFlag : (token: SyntaxKind) => NodeFlags
>token : SyntaxKind
>SyntaxKind : SyntaxKind
>NodeFlags : NodeFlags

    function updateSourceFile(sourceFile: SourceFile, newText: string, textChangeRange: TextChangeRange, aggressiveChecks?: boolean): SourceFile;
>updateSourceFile : (sourceFile: SourceFile, newText: string, textChangeRange: TextChangeRange, aggressiveChecks?: boolean) => SourceFile
>sourceFile : SourceFile
>SourceFile : SourceFile
>newText : string
>textChangeRange : TextChangeRange
>TextChangeRange : TextChangeRange
>aggressiveChecks : boolean
>SourceFile : SourceFile

    function isEvalOrArgumentsIdentifier(node: Node): boolean;
>isEvalOrArgumentsIdentifier : (node: Node) => boolean
>node : Node
>Node : Node

    function createSourceFile(fileName: string, sourceText: string, languageVersion: ScriptTarget, setParentNodes?: boolean): SourceFile;
>createSourceFile : (fileName: string, sourceText: string, languageVersion: ScriptTarget, setParentNodes?: boolean) => SourceFile
>fileName : string
>sourceText : string
>languageVersion : ScriptTarget
>ScriptTarget : ScriptTarget
>setParentNodes : boolean
>SourceFile : SourceFile

    function isLeftHandSideExpression(expr: Expression): boolean;
>isLeftHandSideExpression : (expr: Expression) => boolean
>expr : Expression
>Expression : Expression

    function isAssignmentOperator(token: SyntaxKind): boolean;
>isAssignmentOperator : (token: SyntaxKind) => boolean
>token : SyntaxKind
>SyntaxKind : SyntaxKind
}
declare module "typescript" {
    function createTypeChecker(host: TypeCheckerHost, produceDiagnostics: boolean): TypeChecker;
>createTypeChecker : (host: TypeCheckerHost, produceDiagnostics: boolean) => TypeChecker
>host : TypeCheckerHost
>TypeCheckerHost : TypeCheckerHost
>produceDiagnostics : boolean
>TypeChecker : TypeChecker
}
declare module "typescript" {
    function createCompilerHost(options: CompilerOptions): CompilerHost;
>createCompilerHost : (options: CompilerOptions) => CompilerHost
>options : CompilerOptions
>CompilerOptions : CompilerOptions
>CompilerHost : CompilerHost

    function getPreEmitDiagnostics(program: Program): Diagnostic[];
>getPreEmitDiagnostics : (program: Program) => Diagnostic[]
>program : Program
>Program : Program
>Diagnostic : Diagnostic

    function flattenDiagnosticMessageText(messageText: string | DiagnosticMessageChain, newLine: string): string;
>flattenDiagnosticMessageText : (messageText: string | DiagnosticMessageChain, newLine: string) => string
>messageText : string | DiagnosticMessageChain
>DiagnosticMessageChain : DiagnosticMessageChain
>newLine : string

    function createProgram(rootNames: string[], options: CompilerOptions, host?: CompilerHost): Program;
>createProgram : (rootNames: string[], options: CompilerOptions, host?: CompilerHost) => Program
>rootNames : string[]
>options : CompilerOptions
>CompilerOptions : CompilerOptions
>host : CompilerHost
>CompilerHost : CompilerHost
>Program : Program
}
declare module "typescript" {
    var servicesVersion: string;
>servicesVersion : string

    interface Node {
>Node : Node

        getSourceFile(): SourceFile;
>getSourceFile : () => SourceFile
>SourceFile : SourceFile

        getChildCount(sourceFile?: SourceFile): number;
>getChildCount : (sourceFile?: SourceFile) => number
>sourceFile : SourceFile
>SourceFile : SourceFile

        getChildAt(index: number, sourceFile?: SourceFile): Node;
>getChildAt : (index: number, sourceFile?: SourceFile) => Node
>index : number
>sourceFile : SourceFile
>SourceFile : SourceFile
>Node : Node

        getChildren(sourceFile?: SourceFile): Node[];
>getChildren : (sourceFile?: SourceFile) => Node[]
>sourceFile : SourceFile
>SourceFile : SourceFile
>Node : Node

        getStart(sourceFile?: SourceFile): number;
>getStart : (sourceFile?: SourceFile) => number
>sourceFile : SourceFile
>SourceFile : SourceFile

        getFullStart(): number;
>getFullStart : () => number

        getEnd(): number;
>getEnd : () => number

        getWidth(sourceFile?: SourceFile): number;
>getWidth : (sourceFile?: SourceFile) => number
>sourceFile : SourceFile
>SourceFile : SourceFile

        getFullWidth(): number;
>getFullWidth : () => number

        getLeadingTriviaWidth(sourceFile?: SourceFile): number;
>getLeadingTriviaWidth : (sourceFile?: SourceFile) => number
>sourceFile : SourceFile
>SourceFile : SourceFile

        getFullText(sourceFile?: SourceFile): string;
>getFullText : (sourceFile?: SourceFile) => string
>sourceFile : SourceFile
>SourceFile : SourceFile

        getText(sourceFile?: SourceFile): string;
>getText : (sourceFile?: SourceFile) => string
>sourceFile : SourceFile
>SourceFile : SourceFile

        getFirstToken(sourceFile?: SourceFile): Node;
>getFirstToken : (sourceFile?: SourceFile) => Node
>sourceFile : SourceFile
>SourceFile : SourceFile
>Node : Node

        getLastToken(sourceFile?: SourceFile): Node;
>getLastToken : (sourceFile?: SourceFile) => Node
>sourceFile : SourceFile
>SourceFile : SourceFile
>Node : Node
    }
    interface Symbol {
>Symbol : Symbol

        getFlags(): SymbolFlags;
>getFlags : () => SymbolFlags
>SymbolFlags : SymbolFlags

        getName(): string;
>getName : () => string

        getDeclarations(): Declaration[];
>getDeclarations : () => Declaration[]
>Declaration : Declaration

        getDocumentationComment(): SymbolDisplayPart[];
>getDocumentationComment : () => SymbolDisplayPart[]
>SymbolDisplayPart : SymbolDisplayPart
    }
    interface Type {
>Type : Type

        getFlags(): TypeFlags;
>getFlags : () => TypeFlags
>TypeFlags : TypeFlags

        getSymbol(): Symbol;
>getSymbol : () => Symbol
>Symbol : Symbol

        getProperties(): Symbol[];
>getProperties : () => Symbol[]
>Symbol : Symbol

        getProperty(propertyName: string): Symbol;
>getProperty : (propertyName: string) => Symbol
>propertyName : string
>Symbol : Symbol

        getApparentProperties(): Symbol[];
>getApparentProperties : () => Symbol[]
>Symbol : Symbol

        getCallSignatures(): Signature[];
>getCallSignatures : () => Signature[]
>Signature : Signature

        getConstructSignatures(): Signature[];
>getConstructSignatures : () => Signature[]
>Signature : Signature

        getStringIndexType(): Type;
>getStringIndexType : () => Type
>Type : Type

        getNumberIndexType(): Type;
>getNumberIndexType : () => Type
>Type : Type
    }
    interface Signature {
>Signature : Signature

        getDeclaration(): SignatureDeclaration;
>getDeclaration : () => SignatureDeclaration
>SignatureDeclaration : SignatureDeclaration

        getTypeParameters(): Type[];
>getTypeParameters : () => Type[]
>Type : Type

        getParameters(): Symbol[];
>getParameters : () => Symbol[]
>Symbol : Symbol

        getReturnType(): Type;
>getReturnType : () => Type
>Type : Type

        getDocumentationComment(): SymbolDisplayPart[];
>getDocumentationComment : () => SymbolDisplayPart[]
>SymbolDisplayPart : SymbolDisplayPart
    }
    interface SourceFile {
>SourceFile : SourceFile

        version: string;
>version : string

        scriptSnapshot: IScriptSnapshot;
>scriptSnapshot : IScriptSnapshot
>IScriptSnapshot : IScriptSnapshot

        nameTable: Map<string>;
>nameTable : Map<string>
>Map : Map<T>

        getNamedDeclarations(): Declaration[];
>getNamedDeclarations : () => Declaration[]
>Declaration : Declaration

        getLineAndCharacterOfPosition(pos: number): LineAndCharacter;
>getLineAndCharacterOfPosition : (pos: number) => LineAndCharacter
>pos : number
>LineAndCharacter : LineAndCharacter

        getLineStarts(): number[];
>getLineStarts : () => number[]

        getPositionOfLineAndCharacter(line: number, character: number): number;
>getPositionOfLineAndCharacter : (line: number, character: number) => number
>line : number
>character : number

        update(newText: string, textChangeRange: TextChangeRange): SourceFile;
>update : (newText: string, textChangeRange: TextChangeRange) => SourceFile
>newText : string
>textChangeRange : TextChangeRange
>TextChangeRange : TextChangeRange
>SourceFile : SourceFile
    }
    /**
     * Represents an immutable snapshot of a script at a specified time.Once acquired, the
     * snapshot is observably immutable. i.e. the same calls with the same parameters will return
     * the same values.
     */
    interface IScriptSnapshot {
>IScriptSnapshot : IScriptSnapshot

        /** Gets a portion of the script snapshot specified by [start, end). */
        getText(start: number, end: number): string;
>getText : (start: number, end: number) => string
>start : number
>end : number

        /** Gets the length of this script snapshot. */
        getLength(): number;
>getLength : () => number

        /**
         * Gets the TextChangeRange that describe how the text changed between this text and
         * an older version.  This information is used by the incremental parser to determine
         * what sections of the script need to be re-parsed.  'undefined' can be returned if the
         * change range cannot be determined.  However, in that case, incremental parsing will
         * not happen and the entire document will be re - parsed.
         */
        getChangeRange(oldSnapshot: IScriptSnapshot): TextChangeRange;
>getChangeRange : (oldSnapshot: IScriptSnapshot) => TextChangeRange
>oldSnapshot : IScriptSnapshot
>IScriptSnapshot : IScriptSnapshot
>TextChangeRange : TextChangeRange
    }
    module ScriptSnapshot {
>ScriptSnapshot : typeof ScriptSnapshot

        function fromString(text: string): IScriptSnapshot;
>fromString : (text: string) => IScriptSnapshot
>text : string
>IScriptSnapshot : IScriptSnapshot
    }
    interface PreProcessedFileInfo {
>PreProcessedFileInfo : PreProcessedFileInfo

        referencedFiles: FileReference[];
>referencedFiles : FileReference[]
>FileReference : FileReference

        importedFiles: FileReference[];
>importedFiles : FileReference[]
>FileReference : FileReference

        isLibFile: boolean;
>isLibFile : boolean
    }
    interface LanguageServiceHost {
>LanguageServiceHost : LanguageServiceHost

        getCompilationSettings(): CompilerOptions;
>getCompilationSettings : () => CompilerOptions
>CompilerOptions : CompilerOptions

        getNewLine?(): string;
>getNewLine : () => string

        getScriptFileNames(): string[];
>getScriptFileNames : () => string[]

        getScriptVersion(fileName: string): string;
>getScriptVersion : (fileName: string) => string
>fileName : string

        getScriptSnapshot(fileName: string): IScriptSnapshot;
>getScriptSnapshot : (fileName: string) => IScriptSnapshot
>fileName : string
>IScriptSnapshot : IScriptSnapshot

        getLocalizedDiagnosticMessages?(): any;
>getLocalizedDiagnosticMessages : () => any

        getCancellationToken?(): CancellationToken;
>getCancellationToken : () => CancellationToken
>CancellationToken : CancellationToken

        getCurrentDirectory(): string;
>getCurrentDirectory : () => string

        getDefaultLibFileName(options: CompilerOptions): string;
>getDefaultLibFileName : (options: CompilerOptions) => string
>options : CompilerOptions
>CompilerOptions : CompilerOptions

        log?(s: string): void;
>log : (s: string) => void
>s : string

        trace?(s: string): void;
>trace : (s: string) => void
>s : string

        error?(s: string): void;
>error : (s: string) => void
>s : string
    }
    interface LanguageService {
>LanguageService : LanguageService

        cleanupSemanticCache(): void;
>cleanupSemanticCache : () => void

        getSyntacticDiagnostics(fileName: string): Diagnostic[];
>getSyntacticDiagnostics : (fileName: string) => Diagnostic[]
>fileName : string
>Diagnostic : Diagnostic

        getSemanticDiagnostics(fileName: string): Diagnostic[];
>getSemanticDiagnostics : (fileName: string) => Diagnostic[]
>fileName : string
>Diagnostic : Diagnostic

        getCompilerOptionsDiagnostics(): Diagnostic[];
>getCompilerOptionsDiagnostics : () => Diagnostic[]
>Diagnostic : Diagnostic

        getSyntacticClassifications(fileName: string, span: TextSpan): ClassifiedSpan[];
>getSyntacticClassifications : (fileName: string, span: TextSpan) => ClassifiedSpan[]
>fileName : string
>span : TextSpan
>TextSpan : TextSpan
>ClassifiedSpan : ClassifiedSpan

        getSemanticClassifications(fileName: string, span: TextSpan): ClassifiedSpan[];
>getSemanticClassifications : (fileName: string, span: TextSpan) => ClassifiedSpan[]
>fileName : string
>span : TextSpan
>TextSpan : TextSpan
>ClassifiedSpan : ClassifiedSpan

        getCompletionsAtPosition(fileName: string, position: number): CompletionInfo;
>getCompletionsAtPosition : (fileName: string, position: number) => CompletionInfo
>fileName : string
>position : number
>CompletionInfo : CompletionInfo

        getCompletionEntryDetails(fileName: string, position: number, entryName: string): CompletionEntryDetails;
>getCompletionEntryDetails : (fileName: string, position: number, entryName: string) => CompletionEntryDetails
>fileName : string
>position : number
>entryName : string
>CompletionEntryDetails : CompletionEntryDetails

        getQuickInfoAtPosition(fileName: string, position: number): QuickInfo;
>getQuickInfoAtPosition : (fileName: string, position: number) => QuickInfo
>fileName : string
>position : number
>QuickInfo : QuickInfo

        getNameOrDottedNameSpan(fileName: string, startPos: number, endPos: number): TextSpan;
>getNameOrDottedNameSpan : (fileName: string, startPos: number, endPos: number) => TextSpan
>fileName : string
>startPos : number
>endPos : number
>TextSpan : TextSpan

        getBreakpointStatementAtPosition(fileName: string, position: number): TextSpan;
>getBreakpointStatementAtPosition : (fileName: string, position: number) => TextSpan
>fileName : string
>position : number
>TextSpan : TextSpan

        getSignatureHelpItems(fileName: string, position: number): SignatureHelpItems;
>getSignatureHelpItems : (fileName: string, position: number) => SignatureHelpItems
>fileName : string
>position : number
>SignatureHelpItems : SignatureHelpItems

        getRenameInfo(fileName: string, position: number): RenameInfo;
>getRenameInfo : (fileName: string, position: number) => RenameInfo
>fileName : string
>position : number
>RenameInfo : RenameInfo

        findRenameLocations(fileName: string, position: number, findInStrings: boolean, findInComments: boolean): RenameLocation[];
>findRenameLocations : (fileName: string, position: number, findInStrings: boolean, findInComments: boolean) => RenameLocation[]
>fileName : string
>position : number
>findInStrings : boolean
>findInComments : boolean
>RenameLocation : RenameLocation

        getDefinitionAtPosition(fileName: string, position: number): DefinitionInfo[];
>getDefinitionAtPosition : (fileName: string, position: number) => DefinitionInfo[]
>fileName : string
>position : number
>DefinitionInfo : DefinitionInfo

        getReferencesAtPosition(fileName: string, position: number): ReferenceEntry[];
>getReferencesAtPosition : (fileName: string, position: number) => ReferenceEntry[]
>fileName : string
>position : number
>ReferenceEntry : ReferenceEntry

        getOccurrencesAtPosition(fileName: string, position: number): ReferenceEntry[];
>getOccurrencesAtPosition : (fileName: string, position: number) => ReferenceEntry[]
>fileName : string
>position : number
>ReferenceEntry : ReferenceEntry

        getNavigateToItems(searchValue: string, maxResultCount?: number): NavigateToItem[];
>getNavigateToItems : (searchValue: string, maxResultCount?: number) => NavigateToItem[]
>searchValue : string
>maxResultCount : number
>NavigateToItem : NavigateToItem

        getNavigationBarItems(fileName: string): NavigationBarItem[];
>getNavigationBarItems : (fileName: string) => NavigationBarItem[]
>fileName : string
>NavigationBarItem : NavigationBarItem

        getOutliningSpans(fileName: string): OutliningSpan[];
>getOutliningSpans : (fileName: string) => OutliningSpan[]
>fileName : string
>OutliningSpan : OutliningSpan

        getTodoComments(fileName: string, descriptors: TodoCommentDescriptor[]): TodoComment[];
>getTodoComments : (fileName: string, descriptors: TodoCommentDescriptor[]) => TodoComment[]
>fileName : string
>descriptors : TodoCommentDescriptor[]
>TodoCommentDescriptor : TodoCommentDescriptor
>TodoComment : TodoComment

        getBraceMatchingAtPosition(fileName: string, position: number): TextSpan[];
>getBraceMatchingAtPosition : (fileName: string, position: number) => TextSpan[]
>fileName : string
>position : number
>TextSpan : TextSpan

        getIndentationAtPosition(fileName: string, position: number, options: EditorOptions): number;
>getIndentationAtPosition : (fileName: string, position: number, options: EditorOptions) => number
>fileName : string
>position : number
>options : EditorOptions
>EditorOptions : EditorOptions

        getFormattingEditsForRange(fileName: string, start: number, end: number, options: FormatCodeOptions): TextChange[];
>getFormattingEditsForRange : (fileName: string, start: number, end: number, options: FormatCodeOptions) => TextChange[]
>fileName : string
>start : number
>end : number
>options : FormatCodeOptions
>FormatCodeOptions : FormatCodeOptions
>TextChange : TextChange

        getFormattingEditsForDocument(fileName: string, options: FormatCodeOptions): TextChange[];
>getFormattingEditsForDocument : (fileName: string, options: FormatCodeOptions) => TextChange[]
>fileName : string
>options : FormatCodeOptions
>FormatCodeOptions : FormatCodeOptions
>TextChange : TextChange

        getFormattingEditsAfterKeystroke(fileName: string, position: number, key: string, options: FormatCodeOptions): TextChange[];
>getFormattingEditsAfterKeystroke : (fileName: string, position: number, key: string, options: FormatCodeOptions) => TextChange[]
>fileName : string
>position : number
>key : string
>options : FormatCodeOptions
>FormatCodeOptions : FormatCodeOptions
>TextChange : TextChange

        getEmitOutput(fileName: string): EmitOutput;
>getEmitOutput : (fileName: string) => EmitOutput
>fileName : string
>EmitOutput : EmitOutput

        getProgram(): Program;
>getProgram : () => Program
>Program : Program

        getSourceFile(fileName: string): SourceFile;
>getSourceFile : (fileName: string) => SourceFile
>fileName : string
>SourceFile : SourceFile

        dispose(): void;
>dispose : () => void
    }
    interface ClassifiedSpan {
>ClassifiedSpan : ClassifiedSpan

        textSpan: TextSpan;
>textSpan : TextSpan
>TextSpan : TextSpan

        classificationType: string;
>classificationType : string
    }
    interface NavigationBarItem {
>NavigationBarItem : NavigationBarItem

        text: string;
>text : string

        kind: string;
>kind : string

        kindModifiers: string;
>kindModifiers : string

        spans: TextSpan[];
>spans : TextSpan[]
>TextSpan : TextSpan

        childItems: NavigationBarItem[];
>childItems : NavigationBarItem[]
>NavigationBarItem : NavigationBarItem

        indent: number;
>indent : number

        bolded: boolean;
>bolded : boolean

        grayed: boolean;
>grayed : boolean
    }
    interface TodoCommentDescriptor {
>TodoCommentDescriptor : TodoCommentDescriptor

        text: string;
>text : string

        priority: number;
>priority : number
    }
    interface TodoComment {
>TodoComment : TodoComment

        descriptor: TodoCommentDescriptor;
>descriptor : TodoCommentDescriptor
>TodoCommentDescriptor : TodoCommentDescriptor

        message: string;
>message : string

        position: number;
>position : number
    }
    class TextChange {
>TextChange : TextChange

        span: TextSpan;
>span : TextSpan
>TextSpan : TextSpan

        newText: string;
>newText : string
    }
    interface RenameLocation {
>RenameLocation : RenameLocation

        textSpan: TextSpan;
>textSpan : TextSpan
>TextSpan : TextSpan

        fileName: string;
>fileName : string
    }
    interface ReferenceEntry {
>ReferenceEntry : ReferenceEntry

        textSpan: TextSpan;
>textSpan : TextSpan
>TextSpan : TextSpan

        fileName: string;
>fileName : string

        isWriteAccess: boolean;
>isWriteAccess : boolean
    }
    interface NavigateToItem {
>NavigateToItem : NavigateToItem

        name: string;
>name : string

        kind: string;
>kind : string

        kindModifiers: string;
>kindModifiers : string

        matchKind: string;
>matchKind : string

        fileName: string;
>fileName : string

        textSpan: TextSpan;
>textSpan : TextSpan
>TextSpan : TextSpan

        containerName: string;
>containerName : string

        containerKind: string;
>containerKind : string
    }
    interface EditorOptions {
>EditorOptions : EditorOptions

        IndentSize: number;
>IndentSize : number

        TabSize: number;
>TabSize : number

        NewLineCharacter: string;
>NewLineCharacter : string

        ConvertTabsToSpaces: boolean;
>ConvertTabsToSpaces : boolean
    }
    interface FormatCodeOptions extends EditorOptions {
>FormatCodeOptions : FormatCodeOptions
>EditorOptions : EditorOptions

        InsertSpaceAfterCommaDelimiter: boolean;
>InsertSpaceAfterCommaDelimiter : boolean

        InsertSpaceAfterSemicolonInForStatements: boolean;
>InsertSpaceAfterSemicolonInForStatements : boolean

        InsertSpaceBeforeAndAfterBinaryOperators: boolean;
>InsertSpaceBeforeAndAfterBinaryOperators : boolean

        InsertSpaceAfterKeywordsInControlFlowStatements: boolean;
>InsertSpaceAfterKeywordsInControlFlowStatements : boolean

        InsertSpaceAfterFunctionKeywordForAnonymousFunctions: boolean;
>InsertSpaceAfterFunctionKeywordForAnonymousFunctions : boolean

        InsertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis: boolean;
>InsertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis : boolean

        PlaceOpenBraceOnNewLineForFunctions: boolean;
>PlaceOpenBraceOnNewLineForFunctions : boolean

        PlaceOpenBraceOnNewLineForControlBlocks: boolean;
>PlaceOpenBraceOnNewLineForControlBlocks : boolean

        [s: string]: boolean | number | string;
>s : string
    }
    interface DefinitionInfo {
>DefinitionInfo : DefinitionInfo

        fileName: string;
>fileName : string

        textSpan: TextSpan;
>textSpan : TextSpan
>TextSpan : TextSpan

        kind: string;
>kind : string

        name: string;
>name : string

        containerKind: string;
>containerKind : string

        containerName: string;
>containerName : string
    }
    enum SymbolDisplayPartKind {
>SymbolDisplayPartKind : SymbolDisplayPartKind

        aliasName = 0,
>aliasName : SymbolDisplayPartKind

        className = 1,
>className : SymbolDisplayPartKind

        enumName = 2,
>enumName : SymbolDisplayPartKind

        fieldName = 3,
>fieldName : SymbolDisplayPartKind

        interfaceName = 4,
>interfaceName : SymbolDisplayPartKind

        keyword = 5,
>keyword : SymbolDisplayPartKind

        lineBreak = 6,
>lineBreak : SymbolDisplayPartKind

        numericLiteral = 7,
>numericLiteral : SymbolDisplayPartKind

        stringLiteral = 8,
>stringLiteral : SymbolDisplayPartKind

        localName = 9,
>localName : SymbolDisplayPartKind

        methodName = 10,
>methodName : SymbolDisplayPartKind

        moduleName = 11,
>moduleName : SymbolDisplayPartKind

        operator = 12,
>operator : SymbolDisplayPartKind

        parameterName = 13,
>parameterName : SymbolDisplayPartKind

        propertyName = 14,
>propertyName : SymbolDisplayPartKind

        punctuation = 15,
>punctuation : SymbolDisplayPartKind

        space = 16,
>space : SymbolDisplayPartKind

        text = 17,
>text : SymbolDisplayPartKind

        typeParameterName = 18,
>typeParameterName : SymbolDisplayPartKind

        enumMemberName = 19,
>enumMemberName : SymbolDisplayPartKind

        functionName = 20,
>functionName : SymbolDisplayPartKind

        regularExpressionLiteral = 21,
>regularExpressionLiteral : SymbolDisplayPartKind
    }
    interface SymbolDisplayPart {
>SymbolDisplayPart : SymbolDisplayPart

        text: string;
>text : string

        kind: string;
>kind : string
    }
    interface QuickInfo {
>QuickInfo : QuickInfo

        kind: string;
>kind : string

        kindModifiers: string;
>kindModifiers : string

        textSpan: TextSpan;
>textSpan : TextSpan
>TextSpan : TextSpan

        displayParts: SymbolDisplayPart[];
>displayParts : SymbolDisplayPart[]
>SymbolDisplayPart : SymbolDisplayPart

        documentation: SymbolDisplayPart[];
>documentation : SymbolDisplayPart[]
>SymbolDisplayPart : SymbolDisplayPart
    }
    interface RenameInfo {
>RenameInfo : RenameInfo

        canRename: boolean;
>canRename : boolean

        localizedErrorMessage: string;
>localizedErrorMessage : string

        displayName: string;
>displayName : string

        fullDisplayName: string;
>fullDisplayName : string

        kind: string;
>kind : string

        kindModifiers: string;
>kindModifiers : string

        triggerSpan: TextSpan;
>triggerSpan : TextSpan
>TextSpan : TextSpan
    }
    interface SignatureHelpParameter {
>SignatureHelpParameter : SignatureHelpParameter

        name: string;
>name : string

        documentation: SymbolDisplayPart[];
>documentation : SymbolDisplayPart[]
>SymbolDisplayPart : SymbolDisplayPart

        displayParts: SymbolDisplayPart[];
>displayParts : SymbolDisplayPart[]
>SymbolDisplayPart : SymbolDisplayPart

        isOptional: boolean;
>isOptional : boolean
    }
    /**
     * Represents a single signature to show in signature help.
     * The id is used for subsequent calls into the language service to ask questions about the
     * signature help item in the context of any documents that have been updated.  i.e. after
     * an edit has happened, while signature help is still active, the host can ask important
     * questions like 'what parameter is the user currently contained within?'.
     */
    interface SignatureHelpItem {
>SignatureHelpItem : SignatureHelpItem

        isVariadic: boolean;
>isVariadic : boolean

        prefixDisplayParts: SymbolDisplayPart[];
>prefixDisplayParts : SymbolDisplayPart[]
>SymbolDisplayPart : SymbolDisplayPart

        suffixDisplayParts: SymbolDisplayPart[];
>suffixDisplayParts : SymbolDisplayPart[]
>SymbolDisplayPart : SymbolDisplayPart

        separatorDisplayParts: SymbolDisplayPart[];
>separatorDisplayParts : SymbolDisplayPart[]
>SymbolDisplayPart : SymbolDisplayPart

        parameters: SignatureHelpParameter[];
>parameters : SignatureHelpParameter[]
>SignatureHelpParameter : SignatureHelpParameter

        documentation: SymbolDisplayPart[];
>documentation : SymbolDisplayPart[]
>SymbolDisplayPart : SymbolDisplayPart
    }
    /**
     * Represents a set of signature help items, and the preferred item that should be selected.
     */
    interface SignatureHelpItems {
>SignatureHelpItems : SignatureHelpItems

        items: SignatureHelpItem[];
>items : SignatureHelpItem[]
>SignatureHelpItem : SignatureHelpItem

        applicableSpan: TextSpan;
>applicableSpan : TextSpan
>TextSpan : TextSpan

        selectedItemIndex: number;
>selectedItemIndex : number

        argumentIndex: number;
>argumentIndex : number

        argumentCount: number;
>argumentCount : number
    }
    interface CompletionInfo {
>CompletionInfo : CompletionInfo

        isMemberCompletion: boolean;
>isMemberCompletion : boolean

        isNewIdentifierLocation: boolean;
>isNewIdentifierLocation : boolean

        entries: CompletionEntry[];
>entries : CompletionEntry[]
>CompletionEntry : CompletionEntry
    }
    interface CompletionEntry {
>CompletionEntry : CompletionEntry

        name: string;
>name : string

        kind: string;
>kind : string

        kindModifiers: string;
>kindModifiers : string
    }
    interface CompletionEntryDetails {
>CompletionEntryDetails : CompletionEntryDetails

        name: string;
>name : string

        kind: string;
>kind : string

        kindModifiers: string;
>kindModifiers : string

        displayParts: SymbolDisplayPart[];
>displayParts : SymbolDisplayPart[]
>SymbolDisplayPart : SymbolDisplayPart

        documentation: SymbolDisplayPart[];
>documentation : SymbolDisplayPart[]
>SymbolDisplayPart : SymbolDisplayPart
    }
    interface OutliningSpan {
>OutliningSpan : OutliningSpan

        /** The span of the document to actually collapse. */
        textSpan: TextSpan;
>textSpan : TextSpan
>TextSpan : TextSpan

        /** The span of the document to display when the user hovers over the collapsed span. */
        hintSpan: TextSpan;
>hintSpan : TextSpan
>TextSpan : TextSpan

        /** The text to display in the editor for the collapsed region. */
        bannerText: string;
>bannerText : string

        /**
          * Whether or not this region should be automatically collapsed when
          * the 'Collapse to Definitions' command is invoked.
          */
        autoCollapse: boolean;
>autoCollapse : boolean
    }
    interface EmitOutput {
>EmitOutput : EmitOutput

        outputFiles: OutputFile[];
>outputFiles : OutputFile[]
>OutputFile : OutputFile

        emitSkipped: boolean;
>emitSkipped : boolean
    }
    const enum OutputFileType {
>OutputFileType : OutputFileType

        JavaScript = 0,
>JavaScript : OutputFileType

        SourceMap = 1,
>SourceMap : OutputFileType

        Declaration = 2,
>Declaration : OutputFileType
    }
    interface OutputFile {
>OutputFile : OutputFile

        name: string;
>name : string

        writeByteOrderMark: boolean;
>writeByteOrderMark : boolean

        text: string;
>text : string
    }
    const enum EndOfLineState {
>EndOfLineState : EndOfLineState

        Start = 0,
>Start : EndOfLineState

        InMultiLineCommentTrivia = 1,
>InMultiLineCommentTrivia : EndOfLineState

        InSingleQuoteStringLiteral = 2,
>InSingleQuoteStringLiteral : EndOfLineState

        InDoubleQuoteStringLiteral = 3,
>InDoubleQuoteStringLiteral : EndOfLineState

        InTemplateHeadOrNoSubstitutionTemplate = 4,
>InTemplateHeadOrNoSubstitutionTemplate : EndOfLineState

        InTemplateMiddleOrTail = 5,
>InTemplateMiddleOrTail : EndOfLineState

        InTemplateSubstitutionPosition = 6,
>InTemplateSubstitutionPosition : EndOfLineState
    }
    enum TokenClass {
>TokenClass : TokenClass

        Punctuation = 0,
>Punctuation : TokenClass

        Keyword = 1,
>Keyword : TokenClass

        Operator = 2,
>Operator : TokenClass

        Comment = 3,
>Comment : TokenClass

        Whitespace = 4,
>Whitespace : TokenClass

        Identifier = 5,
>Identifier : TokenClass

        NumberLiteral = 6,
>NumberLiteral : TokenClass

        StringLiteral = 7,
>StringLiteral : TokenClass

        RegExpLiteral = 8,
>RegExpLiteral : TokenClass
    }
    interface ClassificationResult {
>ClassificationResult : ClassificationResult

        finalLexState: EndOfLineState;
>finalLexState : EndOfLineState
>EndOfLineState : EndOfLineState

        entries: ClassificationInfo[];
>entries : ClassificationInfo[]
>ClassificationInfo : ClassificationInfo
    }
    interface ClassificationInfo {
>ClassificationInfo : ClassificationInfo

        length: number;
>length : number

        classification: TokenClass;
>classification : TokenClass
>TokenClass : TokenClass
    }
    interface Classifier {
>Classifier : Classifier

        /**
         * Gives lexical classifications of tokens on a line without any syntactic context.
         * For instance, a token consisting of the text 'string' can be either an identifier
         * named 'string' or the keyword 'string', however, because this classifier is not aware,
         * it relies on certain heuristics to give acceptable results. For classifications where
         * speed trumps accuracy, this function is preferable; however, for true accuracy, the
         * syntactic classifier is ideal. In fact, in certain editing scenarios, combining the
         * lexical, syntactic, and semantic classifiers may issue the best user experience.
         *
         * @param text                      The text of a line to classify.
         * @param lexState                  The state of the lexical classifier at the end of the previous line.
         * @param syntacticClassifierAbsent Whether the client is *not* using a syntactic classifier.
         *                                  If there is no syntactic classifier (syntacticClassifierAbsent=true),
         *                                  certain heuristics may be used in its place; however, if there is a
         *                                  syntactic classifier (syntacticClassifierAbsent=false), certain
         *                                  classifications which may be incorrectly categorized will be given
         *                                  back as Identifiers in order to allow the syntactic classifier to
         *                                  subsume the classification.
         */
        getClassificationsForLine(text: string, lexState: EndOfLineState, syntacticClassifierAbsent: boolean): ClassificationResult;
>getClassificationsForLine : (text: string, lexState: EndOfLineState, syntacticClassifierAbsent: boolean) => ClassificationResult
>text : string
>lexState : EndOfLineState
>EndOfLineState : EndOfLineState
>syntacticClassifierAbsent : boolean
>ClassificationResult : ClassificationResult
    }
    /**
      * The document registry represents a store of SourceFile objects that can be shared between
      * multiple LanguageService instances. A LanguageService instance holds on the SourceFile (AST)
      * of files in the context.
      * SourceFile objects account for most of the memory usage by the language service. Sharing
      * the same DocumentRegistry instance between different instances of LanguageService allow
      * for more efficient memory utilization since all projects will share at least the library
      * file (lib.d.ts).
      *
      * A more advanced use of the document registry is to serialize sourceFile objects to disk
      * and re-hydrate them when needed.
      *
      * To create a default DocumentRegistry, use createDocumentRegistry to create one, and pass it
      * to all subsequent createLanguageService calls.
      */
    interface DocumentRegistry {
>DocumentRegistry : DocumentRegistry

        /**
          * Request a stored SourceFile with a given fileName and compilationSettings.
          * The first call to acquire will call createLanguageServiceSourceFile to generate
          * the SourceFile if was not found in the registry.
          *
          * @param fileName The name of the file requested
          * @param compilationSettings Some compilation settings like target affects the
          * shape of a the resulting SourceFile. This allows the DocumentRegistry to store
          * multiple copies of the same file for different compilation settings.
          * @parm scriptSnapshot Text of the file. Only used if the file was not found
          * in the registry and a new one was created.
          * @parm version Current version of the file. Only used if the file was not found
          * in the registry and a new one was created.
          */
        acquireDocument(fileName: string, compilationSettings: CompilerOptions, scriptSnapshot: IScriptSnapshot, version: string): SourceFile;
>acquireDocument : (fileName: string, compilationSettings: CompilerOptions, scriptSnapshot: IScriptSnapshot, version: string) => SourceFile
>fileName : string
>compilationSettings : CompilerOptions
>CompilerOptions : CompilerOptions
>scriptSnapshot : IScriptSnapshot
>IScriptSnapshot : IScriptSnapshot
>version : string
>SourceFile : SourceFile

        /**
          * Request an updated version of an already existing SourceFile with a given fileName
          * and compilationSettings. The update will intern call updateLanguageServiceSourceFile
          * to get an updated SourceFile.
          *
          * Note: It is not allowed to call update on a SourceFile that was not acquired from this
          * registry originally.
          *
          * @param sourceFile The original sourceFile object to update
          * @param fileName The name of the file requested
          * @param compilationSettings Some compilation settings like target affects the
          * shape of a the resulting SourceFile. This allows the DocumentRegistry to store
          * multiple copies of the same file for different compilation settings.
          * @parm scriptSnapshot Text of the file. Only used if the file was not found
          * in the registry and a new one was created.
          * @parm version Current version of the file. Only used if the file was not found
          * in the registry and a new one was created.
          * @parm textChangeRange Change ranges since the last snapshot. Only used if the file
          * was not found in the registry and a new one was created.
          */
        updateDocument(sourceFile: SourceFile, fileName: string, compilationSettings: CompilerOptions, scriptSnapshot: IScriptSnapshot, version: string, textChangeRange: TextChangeRange): SourceFile;
>updateDocument : (sourceFile: SourceFile, fileName: string, compilationSettings: CompilerOptions, scriptSnapshot: IScriptSnapshot, version: string, textChangeRange: TextChangeRange) => SourceFile
>sourceFile : SourceFile
>SourceFile : SourceFile
>fileName : string
>compilationSettings : CompilerOptions
>CompilerOptions : CompilerOptions
>scriptSnapshot : IScriptSnapshot
>IScriptSnapshot : IScriptSnapshot
>version : string
>textChangeRange : TextChangeRange
>TextChangeRange : TextChangeRange
>SourceFile : SourceFile

        /**
          * Informs the DocumentRegistry that a file is not needed any longer.
          *
          * Note: It is not allowed to call release on a SourceFile that was not acquired from
          * this registry originally.
          *
          * @param fileName The name of the file to be released
          * @param compilationSettings The compilation settings used to acquire the file
          */
        releaseDocument(fileName: string, compilationSettings: CompilerOptions): void;
>releaseDocument : (fileName: string, compilationSettings: CompilerOptions) => void
>fileName : string
>compilationSettings : CompilerOptions
>CompilerOptions : CompilerOptions
    }
    class ScriptElementKind {
>ScriptElementKind : ScriptElementKind

        static unknown: string;
>unknown : string

        static keyword: string;
>keyword : string

        static scriptElement: string;
>scriptElement : string

        static moduleElement: string;
>moduleElement : string

        static classElement: string;
>classElement : string

        static interfaceElement: string;
>interfaceElement : string

        static typeElement: string;
>typeElement : string

        static enumElement: string;
>enumElement : string

        static variableElement: string;
>variableElement : string

        static localVariableElement: string;
>localVariableElement : string

        static functionElement: string;
>functionElement : string

        static localFunctionElement: string;
>localFunctionElement : string

        static memberFunctionElement: string;
>memberFunctionElement : string

        static memberGetAccessorElement: string;
>memberGetAccessorElement : string

        static memberSetAccessorElement: string;
>memberSetAccessorElement : string

        static memberVariableElement: string;
>memberVariableElement : string

        static constructorImplementationElement: string;
>constructorImplementationElement : string

        static callSignatureElement: string;
>callSignatureElement : string

        static indexSignatureElement: string;
>indexSignatureElement : string

        static constructSignatureElement: string;
>constructSignatureElement : string

        static parameterElement: string;
>parameterElement : string

        static typeParameterElement: string;
>typeParameterElement : string

        static primitiveType: string;
>primitiveType : string

        static label: string;
>label : string

        static alias: string;
>alias : string

        static constElement: string;
>constElement : string

        static letElement: string;
>letElement : string
    }
    class ScriptElementKindModifier {
>ScriptElementKindModifier : ScriptElementKindModifier

        static none: string;
>none : string

        static publicMemberModifier: string;
>publicMemberModifier : string

        static privateMemberModifier: string;
>privateMemberModifier : string

        static protectedMemberModifier: string;
>protectedMemberModifier : string

        static exportedModifier: string;
>exportedModifier : string

        static ambientModifier: string;
>ambientModifier : string

        static staticModifier: string;
>staticModifier : string
    }
    class ClassificationTypeNames {
>ClassificationTypeNames : ClassificationTypeNames

        static comment: string;
>comment : string

        static identifier: string;
>identifier : string

        static keyword: string;
>keyword : string

        static numericLiteral: string;
>numericLiteral : string

        static operator: string;
>operator : string

        static stringLiteral: string;
>stringLiteral : string

        static whiteSpace: string;
>whiteSpace : string

        static text: string;
>text : string

        static punctuation: string;
>punctuation : string

        static className: string;
>className : string

        static enumName: string;
>enumName : string

        static interfaceName: string;
>interfaceName : string

        static moduleName: string;
>moduleName : string

        static typeParameterName: string;
>typeParameterName : string

        static typeAlias: string;
>typeAlias : string
    }
    interface DisplayPartsSymbolWriter extends SymbolWriter {
>DisplayPartsSymbolWriter : DisplayPartsSymbolWriter
>SymbolWriter : SymbolWriter

        displayParts(): SymbolDisplayPart[];
>displayParts : () => SymbolDisplayPart[]
>SymbolDisplayPart : SymbolDisplayPart
    }
    function displayPartsToString(displayParts: SymbolDisplayPart[]): string;
>displayPartsToString : (displayParts: SymbolDisplayPart[]) => string
>displayParts : SymbolDisplayPart[]
>SymbolDisplayPart : SymbolDisplayPart

    function getDefaultCompilerOptions(): CompilerOptions;
>getDefaultCompilerOptions : () => CompilerOptions
>CompilerOptions : CompilerOptions

    class OperationCanceledException {
>OperationCanceledException : OperationCanceledException
    }
    class CancellationTokenObject {
>CancellationTokenObject : CancellationTokenObject

        private cancellationToken;
>cancellationToken : any

        static None: CancellationTokenObject;
>None : CancellationTokenObject
>CancellationTokenObject : CancellationTokenObject

        constructor(cancellationToken: CancellationToken);
>cancellationToken : CancellationToken
>CancellationToken : CancellationToken

        isCancellationRequested(): boolean;
>isCancellationRequested : () => boolean

        throwIfCancellationRequested(): void;
>throwIfCancellationRequested : () => void
    }
    function createLanguageServiceSourceFile(fileName: string, scriptSnapshot: IScriptSnapshot, scriptTarget: ScriptTarget, version: string, setNodeParents: boolean): SourceFile;
>createLanguageServiceSourceFile : (fileName: string, scriptSnapshot: IScriptSnapshot, scriptTarget: ScriptTarget, version: string, setNodeParents: boolean) => SourceFile
>fileName : string
>scriptSnapshot : IScriptSnapshot
>IScriptSnapshot : IScriptSnapshot
>scriptTarget : ScriptTarget
>ScriptTarget : ScriptTarget
>version : string
>setNodeParents : boolean
>SourceFile : SourceFile

    var disableIncrementalParsing: boolean;
>disableIncrementalParsing : boolean

    function updateLanguageServiceSourceFile(sourceFile: SourceFile, scriptSnapshot: IScriptSnapshot, version: string, textChangeRange: TextChangeRange, aggressiveChecks?: boolean): SourceFile;
>updateLanguageServiceSourceFile : (sourceFile: SourceFile, scriptSnapshot: IScriptSnapshot, version: string, textChangeRange: TextChangeRange, aggressiveChecks?: boolean) => SourceFile
>sourceFile : SourceFile
>SourceFile : SourceFile
>scriptSnapshot : IScriptSnapshot
>IScriptSnapshot : IScriptSnapshot
>version : string
>textChangeRange : TextChangeRange
>TextChangeRange : TextChangeRange
>aggressiveChecks : boolean
>SourceFile : SourceFile

    function createDocumentRegistry(): DocumentRegistry;
>createDocumentRegistry : () => DocumentRegistry
>DocumentRegistry : DocumentRegistry

    function preProcessFile(sourceText: string, readImportFiles?: boolean): PreProcessedFileInfo;
>preProcessFile : (sourceText: string, readImportFiles?: boolean) => PreProcessedFileInfo
>sourceText : string
>readImportFiles : boolean
>PreProcessedFileInfo : PreProcessedFileInfo

    function createLanguageService(host: LanguageServiceHost, documentRegistry?: DocumentRegistry): LanguageService;
>createLanguageService : (host: LanguageServiceHost, documentRegistry?: DocumentRegistry) => LanguageService
>host : LanguageServiceHost
>LanguageServiceHost : LanguageServiceHost
>documentRegistry : DocumentRegistry
>DocumentRegistry : DocumentRegistry
>LanguageService : LanguageService

    function createClassifier(): Classifier;
>createClassifier : () => Classifier
>Classifier : Classifier

    /**
      * Get the path of the default library file (lib.d.ts) as distributed with the typescript
      * node package.
      * The functionality is not supported if the ts module is consumed outside of a node module.
      */
    function getDefaultLibFilePath(options: CompilerOptions): string;
>getDefaultLibFilePath : (options: CompilerOptions) => string
>options : CompilerOptions
>CompilerOptions : CompilerOptions
}

