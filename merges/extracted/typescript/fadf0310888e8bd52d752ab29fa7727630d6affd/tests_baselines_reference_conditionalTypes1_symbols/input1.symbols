=== tests/cases/conformance/types/conditional/conditionalTypes1.ts ===
type Diff<T, U> = T extends U ? never : T;
>Diff : Symbol(Diff, Decl(conditionalTypes1.ts, 0, 0))
>T : Symbol(T, Decl(conditionalTypes1.ts, 0, 10))
>U : Symbol(U, Decl(conditionalTypes1.ts, 0, 12))
>T : Symbol(T, Decl(conditionalTypes1.ts, 0, 10))
>U : Symbol(U, Decl(conditionalTypes1.ts, 0, 12))
>T : Symbol(T, Decl(conditionalTypes1.ts, 0, 10))

type Filter<T, U> = T extends U ? T : never;
>Filter : Symbol(Filter, Decl(conditionalTypes1.ts, 0, 42))
>T : Symbol(T, Decl(conditionalTypes1.ts, 1, 12))
>U : Symbol(U, Decl(conditionalTypes1.ts, 1, 14))
>T : Symbol(T, Decl(conditionalTypes1.ts, 1, 12))
>U : Symbol(U, Decl(conditionalTypes1.ts, 1, 14))
>T : Symbol(T, Decl(conditionalTypes1.ts, 1, 12))

type NonNullable<T> = Diff<T, null | undefined>;
>NonNullable : Symbol(NonNullable, Decl(conditionalTypes1.ts, 1, 44))
>T : Symbol(T, Decl(conditionalTypes1.ts, 2, 17))
>Diff : Symbol(Diff, Decl(conditionalTypes1.ts, 0, 0))
>T : Symbol(T, Decl(conditionalTypes1.ts, 2, 17))

type T00 = Diff<"a" | "b" | "c" | "d", "a" | "c" | "f">;  // "b" | "d"
>T00 : Symbol(T00, Decl(conditionalTypes1.ts, 2, 48))
>Diff : Symbol(Diff, Decl(conditionalTypes1.ts, 0, 0))

type T01 = Filter<"a" | "b" | "c" | "d", "a" | "c" | "f">;  // "a" | "c"
>T01 : Symbol(T01, Decl(conditionalTypes1.ts, 4, 56))
>Filter : Symbol(Filter, Decl(conditionalTypes1.ts, 0, 42))

type T02 = Diff<string | number | (() => void), Function>;  // string | number
>T02 : Symbol(T02, Decl(conditionalTypes1.ts, 5, 58))
>Diff : Symbol(Diff, Decl(conditionalTypes1.ts, 0, 0))
>Function : Symbol(Function, Decl(lib.d.ts, --, --), Decl(lib.d.ts, --, --))

type T03 = Filter<string | number | (() => void), Function>;  // () => void
>T03 : Symbol(T03, Decl(conditionalTypes1.ts, 7, 58))
>Filter : Symbol(Filter, Decl(conditionalTypes1.ts, 0, 42))
>Function : Symbol(Function, Decl(lib.d.ts, --, --), Decl(lib.d.ts, --, --))

type T04 = NonNullable<string | number | undefined>;  // string | number
>T04 : Symbol(T04, Decl(conditionalTypes1.ts, 8, 60))
>NonNullable : Symbol(NonNullable, Decl(conditionalTypes1.ts, 1, 44))

type T05 = NonNullable<(() => string) | string[] | null | undefined>;  // (() => string) | string[]
>T05 : Symbol(T05, Decl(conditionalTypes1.ts, 10, 52))
>NonNullable : Symbol(NonNullable, Decl(conditionalTypes1.ts, 1, 44))

function f1<T>(x: T, y: NonNullable<T>) {
>f1 : Symbol(f1, Decl(conditionalTypes1.ts, 11, 69))
>T : Symbol(T, Decl(conditionalTypes1.ts, 13, 12))
>x : Symbol(x, Decl(conditionalTypes1.ts, 13, 15))
>T : Symbol(T, Decl(conditionalTypes1.ts, 13, 12))
>y : Symbol(y, Decl(conditionalTypes1.ts, 13, 20))
>NonNullable : Symbol(NonNullable, Decl(conditionalTypes1.ts, 1, 44))
>T : Symbol(T, Decl(conditionalTypes1.ts, 13, 12))

    x = y;
>x : Symbol(x, Decl(conditionalTypes1.ts, 13, 15))
>y : Symbol(y, Decl(conditionalTypes1.ts, 13, 20))

    y = x;  // Error
>y : Symbol(y, Decl(conditionalTypes1.ts, 13, 20))
>x : Symbol(x, Decl(conditionalTypes1.ts, 13, 15))
}

function f2<T extends string | undefined>(x: T, y: NonNullable<T>) {
>f2 : Symbol(f2, Decl(conditionalTypes1.ts, 16, 1))
>T : Symbol(T, Decl(conditionalTypes1.ts, 18, 12))
>x : Symbol(x, Decl(conditionalTypes1.ts, 18, 42))
>T : Symbol(T, Decl(conditionalTypes1.ts, 18, 12))
>y : Symbol(y, Decl(conditionalTypes1.ts, 18, 47))
>NonNullable : Symbol(NonNullable, Decl(conditionalTypes1.ts, 1, 44))
>T : Symbol(T, Decl(conditionalTypes1.ts, 18, 12))

    x = y;
>x : Symbol(x, Decl(conditionalTypes1.ts, 18, 42))
>y : Symbol(y, Decl(conditionalTypes1.ts, 18, 47))

    y = x;  // Error
>y : Symbol(y, Decl(conditionalTypes1.ts, 18, 47))
>x : Symbol(x, Decl(conditionalTypes1.ts, 18, 42))

    let s1: string = x;  // Error
>s1 : Symbol(s1, Decl(conditionalTypes1.ts, 21, 7))
>x : Symbol(x, Decl(conditionalTypes1.ts, 18, 42))

    let s2: string = y;
>s2 : Symbol(s2, Decl(conditionalTypes1.ts, 22, 7))
>y : Symbol(y, Decl(conditionalTypes1.ts, 18, 47))
}

function f3<T>(x: Partial<T>[keyof T], y: NonNullable<Partial<T>[keyof T]>) {
>f3 : Symbol(f3, Decl(conditionalTypes1.ts, 23, 1))
>T : Symbol(T, Decl(conditionalTypes1.ts, 25, 12))
>x : Symbol(x, Decl(conditionalTypes1.ts, 25, 15))
>Partial : Symbol(Partial, Decl(lib.d.ts, --, --))
>T : Symbol(T, Decl(conditionalTypes1.ts, 25, 12))
>T : Symbol(T, Decl(conditionalTypes1.ts, 25, 12))
>y : Symbol(y, Decl(conditionalTypes1.ts, 25, 38))
>NonNullable : Symbol(NonNullable, Decl(conditionalTypes1.ts, 1, 44))
>Partial : Symbol(Partial, Decl(lib.d.ts, --, --))
>T : Symbol(T, Decl(conditionalTypes1.ts, 25, 12))
>T : Symbol(T, Decl(conditionalTypes1.ts, 25, 12))

    x = y;
>x : Symbol(x, Decl(conditionalTypes1.ts, 25, 15))
>y : Symbol(y, Decl(conditionalTypes1.ts, 25, 38))

    y = x;  // Error
>y : Symbol(y, Decl(conditionalTypes1.ts, 25, 38))
>x : Symbol(x, Decl(conditionalTypes1.ts, 25, 15))
}

function f4<T extends { x: string | undefined }>(x: T["x"], y: NonNullable<T["x"]>) {
>f4 : Symbol(f4, Decl(conditionalTypes1.ts, 28, 1))
>T : Symbol(T, Decl(conditionalTypes1.ts, 30, 12))
>x : Symbol(x, Decl(conditionalTypes1.ts, 30, 23))
>x : Symbol(x, Decl(conditionalTypes1.ts, 30, 49))
>T : Symbol(T, Decl(conditionalTypes1.ts, 30, 12))
>y : Symbol(y, Decl(conditionalTypes1.ts, 30, 59))
>NonNullable : Symbol(NonNullable, Decl(conditionalTypes1.ts, 1, 44))
>T : Symbol(T, Decl(conditionalTypes1.ts, 30, 12))

    x = y;
>x : Symbol(x, Decl(conditionalTypes1.ts, 30, 49))
>y : Symbol(y, Decl(conditionalTypes1.ts, 30, 59))

    y = x;  // Error
>y : Symbol(y, Decl(conditionalTypes1.ts, 30, 59))
>x : Symbol(x, Decl(conditionalTypes1.ts, 30, 49))

    let s1: string = x;  // Error
>s1 : Symbol(s1, Decl(conditionalTypes1.ts, 33, 7))
>x : Symbol(x, Decl(conditionalTypes1.ts, 30, 49))

    let s2: string = y;
>s2 : Symbol(s2, Decl(conditionalTypes1.ts, 34, 7))
>y : Symbol(y, Decl(conditionalTypes1.ts, 30, 59))
}

type Options = { k: "a", a: number } | { k: "b", b: string } | { k: "c", c: boolean };
>Options : Symbol(Options, Decl(conditionalTypes1.ts, 35, 1))
>k : Symbol(k, Decl(conditionalTypes1.ts, 37, 16))
>a : Symbol(a, Decl(conditionalTypes1.ts, 37, 24))
>k : Symbol(k, Decl(conditionalTypes1.ts, 37, 40))
>b : Symbol(b, Decl(conditionalTypes1.ts, 37, 48))
>k : Symbol(k, Decl(conditionalTypes1.ts, 37, 64))
>c : Symbol(c, Decl(conditionalTypes1.ts, 37, 72))

type T10 = Diff<Options, { k: "a" | "b" }>;  // { k: "c", c: boolean }
>T10 : Symbol(T10, Decl(conditionalTypes1.ts, 37, 86))
>Diff : Symbol(Diff, Decl(conditionalTypes1.ts, 0, 0))
>Options : Symbol(Options, Decl(conditionalTypes1.ts, 35, 1))
>k : Symbol(k, Decl(conditionalTypes1.ts, 39, 26))

type T11 = Filter<Options, { k: "a" | "b" }>;  // { k: "a", a: number } | { k: "b", b: string }
>T11 : Symbol(T11, Decl(conditionalTypes1.ts, 39, 43))
>Filter : Symbol(Filter, Decl(conditionalTypes1.ts, 0, 42))
>Options : Symbol(Options, Decl(conditionalTypes1.ts, 35, 1))
>k : Symbol(k, Decl(conditionalTypes1.ts, 40, 28))

type T12 = Diff<Options, { k: "a" } | { k: "b" }>;  // { k: "c", c: boolean }
>T12 : Symbol(T12, Decl(conditionalTypes1.ts, 40, 45))
>Diff : Symbol(Diff, Decl(conditionalTypes1.ts, 0, 0))
>Options : Symbol(Options, Decl(conditionalTypes1.ts, 35, 1))
>k : Symbol(k, Decl(conditionalTypes1.ts, 42, 26))
>k : Symbol(k, Decl(conditionalTypes1.ts, 42, 39))

type T13 = Filter<Options, { k: "a" } | { k: "b" }>;  // { k: "a", a: number } | { k: "b", b: string }
>T13 : Symbol(T13, Decl(conditionalTypes1.ts, 42, 50))
>Filter : Symbol(Filter, Decl(conditionalTypes1.ts, 0, 42))
>Options : Symbol(Options, Decl(conditionalTypes1.ts, 35, 1))
>k : Symbol(k, Decl(conditionalTypes1.ts, 43, 28))
>k : Symbol(k, Decl(conditionalTypes1.ts, 43, 41))

type T14 = Diff<Options, { q: "a" }>;  // Options
>T14 : Symbol(T14, Decl(conditionalTypes1.ts, 43, 52))
>Diff : Symbol(Diff, Decl(conditionalTypes1.ts, 0, 0))
>Options : Symbol(Options, Decl(conditionalTypes1.ts, 35, 1))
>q : Symbol(q, Decl(conditionalTypes1.ts, 45, 26))

type T15 = Filter<Options, { q: "a" }>;  // never
>T15 : Symbol(T15, Decl(conditionalTypes1.ts, 45, 37))
>Filter : Symbol(Filter, Decl(conditionalTypes1.ts, 0, 42))
>Options : Symbol(Options, Decl(conditionalTypes1.ts, 35, 1))
>q : Symbol(q, Decl(conditionalTypes1.ts, 46, 28))

declare function f5<T extends Options, K extends string>(p: K): Filter<T, { k: K }>;
>f5 : Symbol(f5, Decl(conditionalTypes1.ts, 46, 39))
>T : Symbol(T, Decl(conditionalTypes1.ts, 48, 20))
>Options : Symbol(Options, Decl(conditionalTypes1.ts, 35, 1))
>K : Symbol(K, Decl(conditionalTypes1.ts, 48, 38))
>p : Symbol(p, Decl(conditionalTypes1.ts, 48, 57))
>K : Symbol(K, Decl(conditionalTypes1.ts, 48, 38))
>Filter : Symbol(Filter, Decl(conditionalTypes1.ts, 0, 42))
>T : Symbol(T, Decl(conditionalTypes1.ts, 48, 20))
>k : Symbol(k, Decl(conditionalTypes1.ts, 48, 75))
>K : Symbol(K, Decl(conditionalTypes1.ts, 48, 38))

let x0 = f5("a");  // { k: "a", a: number }
>x0 : Symbol(x0, Decl(conditionalTypes1.ts, 49, 3))
>f5 : Symbol(f5, Decl(conditionalTypes1.ts, 46, 39))

type OptionsOfKind<K extends Options["k"]> = Filter<Options, { k: K }>;
>OptionsOfKind : Symbol(OptionsOfKind, Decl(conditionalTypes1.ts, 49, 17))
>K : Symbol(K, Decl(conditionalTypes1.ts, 51, 19))
>Options : Symbol(Options, Decl(conditionalTypes1.ts, 35, 1))
>Filter : Symbol(Filter, Decl(conditionalTypes1.ts, 0, 42))
>Options : Symbol(Options, Decl(conditionalTypes1.ts, 35, 1))
>k : Symbol(k, Decl(conditionalTypes1.ts, 51, 62))
>K : Symbol(K, Decl(conditionalTypes1.ts, 51, 19))

type T16 = OptionsOfKind<"a" | "b">;  // { k: "a", a: number } | { k: "b", b: string }
>T16 : Symbol(T16, Decl(conditionalTypes1.ts, 51, 71))
>OptionsOfKind : Symbol(OptionsOfKind, Decl(conditionalTypes1.ts, 49, 17))

type Select<T, K extends keyof T, V extends T[K]> = Filter<T, { [P in K]: V }>;
>Select : Symbol(Select, Decl(conditionalTypes1.ts, 53, 36))
>T : Symbol(T, Decl(conditionalTypes1.ts, 55, 12))
>K : Symbol(K, Decl(conditionalTypes1.ts, 55, 14))
>T : Symbol(T, Decl(conditionalTypes1.ts, 55, 12))
>V : Symbol(V, Decl(conditionalTypes1.ts, 55, 33))
>T : Symbol(T, Decl(conditionalTypes1.ts, 55, 12))
>K : Symbol(K, Decl(conditionalTypes1.ts, 55, 14))
>Filter : Symbol(Filter, Decl(conditionalTypes1.ts, 0, 42))
>T : Symbol(T, Decl(conditionalTypes1.ts, 55, 12))
>P : Symbol(P, Decl(conditionalTypes1.ts, 55, 65))
>K : Symbol(K, Decl(conditionalTypes1.ts, 55, 14))
>V : Symbol(V, Decl(conditionalTypes1.ts, 55, 33))

type T17 = Select<Options, "k", "a" | "b">;  // // { k: "a", a: number } | { k: "b", b: string }
>T17 : Symbol(T17, Decl(conditionalTypes1.ts, 55, 79))
>Select : Symbol(Select, Decl(conditionalTypes1.ts, 53, 36))
>Options : Symbol(Options, Decl(conditionalTypes1.ts, 35, 1))

type TypeName<T> =
>TypeName : Symbol(TypeName, Decl(conditionalTypes1.ts, 57, 43))
>T : Symbol(T, Decl(conditionalTypes1.ts, 59, 14))

    T extends string ? "string" :
>T : Symbol(T, Decl(conditionalTypes1.ts, 59, 14))

    T extends number ? "number" :
>T : Symbol(T, Decl(conditionalTypes1.ts, 59, 14))

    T extends boolean ? "boolean" :
>T : Symbol(T, Decl(conditionalTypes1.ts, 59, 14))

    T extends undefined ? "undefined" :
>T : Symbol(T, Decl(conditionalTypes1.ts, 59, 14))

    T extends Function ? "function" :
>T : Symbol(T, Decl(conditionalTypes1.ts, 59, 14))
>Function : Symbol(Function, Decl(lib.d.ts, --, --), Decl(lib.d.ts, --, --))

    "object";

type T20 = TypeName<string | (() => void)>;  // "string" | "function"
>T20 : Symbol(T20, Decl(conditionalTypes1.ts, 65, 13))
>TypeName : Symbol(TypeName, Decl(conditionalTypes1.ts, 57, 43))

type T21 = TypeName<any>;  // "string" | "number" | "boolean" | "undefined" | "function" | "object"
>T21 : Symbol(T21, Decl(conditionalTypes1.ts, 67, 43))
>TypeName : Symbol(TypeName, Decl(conditionalTypes1.ts, 57, 43))

type T22 = TypeName<never>;  // "string" | "number" | "boolean" | "undefined" | "function" | "object"
>T22 : Symbol(T22, Decl(conditionalTypes1.ts, 68, 25))
>TypeName : Symbol(TypeName, Decl(conditionalTypes1.ts, 57, 43))

type T23 = TypeName<{}>;  // "object"
>T23 : Symbol(T23, Decl(conditionalTypes1.ts, 69, 27))
>TypeName : Symbol(TypeName, Decl(conditionalTypes1.ts, 57, 43))

type KnockoutObservable<T> = { object: T };
>KnockoutObservable : Symbol(KnockoutObservable, Decl(conditionalTypes1.ts, 70, 24))
>T : Symbol(T, Decl(conditionalTypes1.ts, 72, 24))
>object : Symbol(object, Decl(conditionalTypes1.ts, 72, 30))
>T : Symbol(T, Decl(conditionalTypes1.ts, 72, 24))

type KnockoutObservableArray<T> = { array: T };
>KnockoutObservableArray : Symbol(KnockoutObservableArray, Decl(conditionalTypes1.ts, 72, 43))
>T : Symbol(T, Decl(conditionalTypes1.ts, 73, 29))
>array : Symbol(array, Decl(conditionalTypes1.ts, 73, 35))
>T : Symbol(T, Decl(conditionalTypes1.ts, 73, 29))

type KnockedOut<T> = T extends any[] ? KnockoutObservableArray<T[number]> : KnockoutObservable<T>;
>KnockedOut : Symbol(KnockedOut, Decl(conditionalTypes1.ts, 73, 47))
>T : Symbol(T, Decl(conditionalTypes1.ts, 75, 16))
>T : Symbol(T, Decl(conditionalTypes1.ts, 75, 16))
>KnockoutObservableArray : Symbol(KnockoutObservableArray, Decl(conditionalTypes1.ts, 72, 43))
>T : Symbol(T, Decl(conditionalTypes1.ts, 75, 16))
>KnockoutObservable : Symbol(KnockoutObservable, Decl(conditionalTypes1.ts, 70, 24))
>T : Symbol(T, Decl(conditionalTypes1.ts, 75, 16))

type KnockedOutObj<T> = {
>KnockedOutObj : Symbol(KnockedOutObj, Decl(conditionalTypes1.ts, 75, 98))
>T : Symbol(T, Decl(conditionalTypes1.ts, 77, 19))

    [P in keyof T]: KnockedOut<T[P]>;
>P : Symbol(P, Decl(conditionalTypes1.ts, 78, 5))
>T : Symbol(T, Decl(conditionalTypes1.ts, 77, 19))
>KnockedOut : Symbol(KnockedOut, Decl(conditionalTypes1.ts, 73, 47))
>T : Symbol(T, Decl(conditionalTypes1.ts, 77, 19))
>P : Symbol(P, Decl(conditionalTypes1.ts, 78, 5))
}

interface Item {
>Item : Symbol(Item, Decl(conditionalTypes1.ts, 79, 1))

    id: number;
>id : Symbol(Item.id, Decl(conditionalTypes1.ts, 81, 16))

    name: string;
>name : Symbol(Item.name, Decl(conditionalTypes1.ts, 82, 15))

    subitems: string[];
>subitems : Symbol(Item.subitems, Decl(conditionalTypes1.ts, 83, 17))
}

type KOItem = KnockedOutObj<Item>;
>KOItem : Symbol(KOItem, Decl(conditionalTypes1.ts, 85, 1))
>KnockedOutObj : Symbol(KnockedOutObj, Decl(conditionalTypes1.ts, 75, 98))
>Item : Symbol(Item, Decl(conditionalTypes1.ts, 79, 1))

interface Part {
>Part : Symbol(Part, Decl(conditionalTypes1.ts, 87, 34))

    id: number;
>id : Symbol(Part.id, Decl(conditionalTypes1.ts, 89, 16))

    name: string;
>name : Symbol(Part.name, Decl(conditionalTypes1.ts, 90, 15))

    subparts: Part[];
>subparts : Symbol(Part.subparts, Decl(conditionalTypes1.ts, 91, 17))
>Part : Symbol(Part, Decl(conditionalTypes1.ts, 87, 34))

    updatePart(newName: string): void;
>updatePart : Symbol(Part.updatePart, Decl(conditionalTypes1.ts, 92, 21))
>newName : Symbol(newName, Decl(conditionalTypes1.ts, 93, 15))
}

type FunctionPropertyNames<T> = { [K in keyof T]: T[K] extends Function ? K : never }[keyof T];
>FunctionPropertyNames : Symbol(FunctionPropertyNames, Decl(conditionalTypes1.ts, 94, 1))
>T : Symbol(T, Decl(conditionalTypes1.ts, 96, 27))
>K : Symbol(K, Decl(conditionalTypes1.ts, 96, 35))
>T : Symbol(T, Decl(conditionalTypes1.ts, 96, 27))
>T : Symbol(T, Decl(conditionalTypes1.ts, 96, 27))
>K : Symbol(K, Decl(conditionalTypes1.ts, 96, 35))
>Function : Symbol(Function, Decl(lib.d.ts, --, --), Decl(lib.d.ts, --, --))
>K : Symbol(K, Decl(conditionalTypes1.ts, 96, 35))
>T : Symbol(T, Decl(conditionalTypes1.ts, 96, 27))

type FunctionProperties<T> = Pick<T, FunctionPropertyNames<T>>;
>FunctionProperties : Symbol(FunctionProperties, Decl(conditionalTypes1.ts, 96, 95))
>T : Symbol(T, Decl(conditionalTypes1.ts, 97, 24))
>Pick : Symbol(Pick, Decl(lib.d.ts, --, --))
>T : Symbol(T, Decl(conditionalTypes1.ts, 97, 24))
>FunctionPropertyNames : Symbol(FunctionPropertyNames, Decl(conditionalTypes1.ts, 94, 1))
>T : Symbol(T, Decl(conditionalTypes1.ts, 97, 24))

type NonFunctionPropertyNames<T> = { [K in keyof T]: T[K] extends Function ? never : K }[keyof T];
>NonFunctionPropertyNames : Symbol(NonFunctionPropertyNames, Decl(conditionalTypes1.ts, 97, 63))
>T : Symbol(T, Decl(conditionalTypes1.ts, 99, 30))
>K : Symbol(K, Decl(conditionalTypes1.ts, 99, 38))
>T : Symbol(T, Decl(conditionalTypes1.ts, 99, 30))
>T : Symbol(T, Decl(conditionalTypes1.ts, 99, 30))
>K : Symbol(K, Decl(conditionalTypes1.ts, 99, 38))
>Function : Symbol(Function, Decl(lib.d.ts, --, --), Decl(lib.d.ts, --, --))
>K : Symbol(K, Decl(conditionalTypes1.ts, 99, 38))
>T : Symbol(T, Decl(conditionalTypes1.ts, 99, 30))

type NonFunctionProperties<T> = Pick<T, NonFunctionPropertyNames<T>>;
>NonFunctionProperties : Symbol(NonFunctionProperties, Decl(conditionalTypes1.ts, 99, 98))
>T : Symbol(T, Decl(conditionalTypes1.ts, 100, 27))
>Pick : Symbol(Pick, Decl(lib.d.ts, --, --))
>T : Symbol(T, Decl(conditionalTypes1.ts, 100, 27))
>NonFunctionPropertyNames : Symbol(NonFunctionPropertyNames, Decl(conditionalTypes1.ts, 97, 63))
>T : Symbol(T, Decl(conditionalTypes1.ts, 100, 27))

type T30 = FunctionProperties<Part>;
>T30 : Symbol(T30, Decl(conditionalTypes1.ts, 100, 69))
>FunctionProperties : Symbol(FunctionProperties, Decl(conditionalTypes1.ts, 96, 95))
>Part : Symbol(Part, Decl(conditionalTypes1.ts, 87, 34))

type T31 = NonFunctionProperties<Part>;
>T31 : Symbol(T31, Decl(conditionalTypes1.ts, 102, 36))
>NonFunctionProperties : Symbol(NonFunctionProperties, Decl(conditionalTypes1.ts, 99, 98))
>Part : Symbol(Part, Decl(conditionalTypes1.ts, 87, 34))

function f7<T>(x: T, y: FunctionProperties<T>, z: NonFunctionProperties<T>) {
>f7 : Symbol(f7, Decl(conditionalTypes1.ts, 103, 39))
>T : Symbol(T, Decl(conditionalTypes1.ts, 105, 12))
>x : Symbol(x, Decl(conditionalTypes1.ts, 105, 15))
>T : Symbol(T, Decl(conditionalTypes1.ts, 105, 12))
>y : Symbol(y, Decl(conditionalTypes1.ts, 105, 20))
>FunctionProperties : Symbol(FunctionProperties, Decl(conditionalTypes1.ts, 96, 95))
>T : Symbol(T, Decl(conditionalTypes1.ts, 105, 12))
>z : Symbol(z, Decl(conditionalTypes1.ts, 105, 46))
>NonFunctionProperties : Symbol(NonFunctionProperties, Decl(conditionalTypes1.ts, 99, 98))
>T : Symbol(T, Decl(conditionalTypes1.ts, 105, 12))

    x = y;  // Error
>x : Symbol(x, Decl(conditionalTypes1.ts, 105, 15))
>y : Symbol(y, Decl(conditionalTypes1.ts, 105, 20))

    x = z;  // Error
>x : Symbol(x, Decl(conditionalTypes1.ts, 105, 15))
>z : Symbol(z, Decl(conditionalTypes1.ts, 105, 46))

    y = x;
>y : Symbol(y, Decl(conditionalTypes1.ts, 105, 20))
>x : Symbol(x, Decl(conditionalTypes1.ts, 105, 15))

    y = z;  // Error
>y : Symbol(y, Decl(conditionalTypes1.ts, 105, 20))
>z : Symbol(z, Decl(conditionalTypes1.ts, 105, 46))

    z = x;
>z : Symbol(z, Decl(conditionalTypes1.ts, 105, 46))
>x : Symbol(x, Decl(conditionalTypes1.ts, 105, 15))

    z = y;  // Error
>z : Symbol(z, Decl(conditionalTypes1.ts, 105, 46))
>y : Symbol(y, Decl(conditionalTypes1.ts, 105, 20))
}

function f8<T>(x: keyof T, y: FunctionPropertyNames<T>, z: NonFunctionPropertyNames<T>) {
>f8 : Symbol(f8, Decl(conditionalTypes1.ts, 112, 1))
>T : Symbol(T, Decl(conditionalTypes1.ts, 114, 12))
>x : Symbol(x, Decl(conditionalTypes1.ts, 114, 15))
>T : Symbol(T, Decl(conditionalTypes1.ts, 114, 12))
>y : Symbol(y, Decl(conditionalTypes1.ts, 114, 26))
>FunctionPropertyNames : Symbol(FunctionPropertyNames, Decl(conditionalTypes1.ts, 94, 1))
>T : Symbol(T, Decl(conditionalTypes1.ts, 114, 12))
>z : Symbol(z, Decl(conditionalTypes1.ts, 114, 55))
>NonFunctionPropertyNames : Symbol(NonFunctionPropertyNames, Decl(conditionalTypes1.ts, 97, 63))
>T : Symbol(T, Decl(conditionalTypes1.ts, 114, 12))

    x = y;
>x : Symbol(x, Decl(conditionalTypes1.ts, 114, 15))
>y : Symbol(y, Decl(conditionalTypes1.ts, 114, 26))

    x = z;
>x : Symbol(x, Decl(conditionalTypes1.ts, 114, 15))
>z : Symbol(z, Decl(conditionalTypes1.ts, 114, 55))

    y = x;  // Error
>y : Symbol(y, Decl(conditionalTypes1.ts, 114, 26))
>x : Symbol(x, Decl(conditionalTypes1.ts, 114, 15))

    y = z;  // Error
>y : Symbol(y, Decl(conditionalTypes1.ts, 114, 26))
>z : Symbol(z, Decl(conditionalTypes1.ts, 114, 55))

    z = x;  // Error
>z : Symbol(z, Decl(conditionalTypes1.ts, 114, 55))
>x : Symbol(x, Decl(conditionalTypes1.ts, 114, 15))

    z = y;  // Error
>z : Symbol(z, Decl(conditionalTypes1.ts, 114, 55))
>y : Symbol(y, Decl(conditionalTypes1.ts, 114, 26))
}

type DeepReadonly<T> =
>DeepReadonly : Symbol(DeepReadonly, Decl(conditionalTypes1.ts, 121, 1))
>T : Symbol(T, Decl(conditionalTypes1.ts, 123, 18))

    T extends any[] ? DeepReadonlyArray<T[number]> :
>T : Symbol(T, Decl(conditionalTypes1.ts, 123, 18))
>DeepReadonlyArray : Symbol(DeepReadonlyArray, Decl(conditionalTypes1.ts, 126, 6))
>T : Symbol(T, Decl(conditionalTypes1.ts, 123, 18))

    T extends object ? DeepReadonlyObject<T> :
>T : Symbol(T, Decl(conditionalTypes1.ts, 123, 18))
>DeepReadonlyObject : Symbol(DeepReadonlyObject, Decl(conditionalTypes1.ts, 128, 72))
>T : Symbol(T, Decl(conditionalTypes1.ts, 123, 18))

    T;
>T : Symbol(T, Decl(conditionalTypes1.ts, 123, 18))

interface DeepReadonlyArray<T> extends ReadonlyArray<DeepReadonly<T>> {}
>DeepReadonlyArray : Symbol(DeepReadonlyArray, Decl(conditionalTypes1.ts, 126, 6))
>T : Symbol(T, Decl(conditionalTypes1.ts, 128, 28))
>ReadonlyArray : Symbol(ReadonlyArray, Decl(lib.d.ts, --, --))
>DeepReadonly : Symbol(DeepReadonly, Decl(conditionalTypes1.ts, 121, 1))
>T : Symbol(T, Decl(conditionalTypes1.ts, 128, 28))

type DeepReadonlyObject<T> = {
>DeepReadonlyObject : Symbol(DeepReadonlyObject, Decl(conditionalTypes1.ts, 128, 72))
>T : Symbol(T, Decl(conditionalTypes1.ts, 130, 24))

    readonly [P in NonFunctionPropertyNames<T>]: DeepReadonly<T[P]>;
>P : Symbol(P, Decl(conditionalTypes1.ts, 131, 14))
>NonFunctionPropertyNames : Symbol(NonFunctionPropertyNames, Decl(conditionalTypes1.ts, 97, 63))
>T : Symbol(T, Decl(conditionalTypes1.ts, 130, 24))
>DeepReadonly : Symbol(DeepReadonly, Decl(conditionalTypes1.ts, 121, 1))
>T : Symbol(T, Decl(conditionalTypes1.ts, 130, 24))
>P : Symbol(P, Decl(conditionalTypes1.ts, 131, 14))

};

function f10(part: DeepReadonly<Part>) {
>f10 : Symbol(f10, Decl(conditionalTypes1.ts, 132, 2))
>part : Symbol(part, Decl(conditionalTypes1.ts, 134, 13))
>DeepReadonly : Symbol(DeepReadonly, Decl(conditionalTypes1.ts, 121, 1))
>Part : Symbol(Part, Decl(conditionalTypes1.ts, 87, 34))

    let name: string = part.name;
>name : Symbol(name, Decl(conditionalTypes1.ts, 135, 7))
>part.name : Symbol(name)
>part : Symbol(part, Decl(conditionalTypes1.ts, 134, 13))
>name : Symbol(name)

    let id: number = part.subparts[0].id;
>id : Symbol(id, Decl(conditionalTypes1.ts, 136, 7))
>part.subparts[0].id : Symbol(id)
>part.subparts : Symbol(subparts)
>part : Symbol(part, Decl(conditionalTypes1.ts, 134, 13))
>subparts : Symbol(subparts)
>id : Symbol(id)

    part.id = part.id;  // Error
>part.id : Symbol(id)
>part : Symbol(part, Decl(conditionalTypes1.ts, 134, 13))
>id : Symbol(id)
>part.id : Symbol(id)
>part : Symbol(part, Decl(conditionalTypes1.ts, 134, 13))
>id : Symbol(id)

    part.subparts[0] = part.subparts[0];  // Error
>part.subparts : Symbol(subparts)
>part : Symbol(part, Decl(conditionalTypes1.ts, 134, 13))
>subparts : Symbol(subparts)
>part.subparts : Symbol(subparts)
>part : Symbol(part, Decl(conditionalTypes1.ts, 134, 13))
>subparts : Symbol(subparts)

    part.subparts[0].id = part.subparts[0].id;  // Error
>part.subparts[0].id : Symbol(id)
>part.subparts : Symbol(subparts)
>part : Symbol(part, Decl(conditionalTypes1.ts, 134, 13))
>subparts : Symbol(subparts)
>id : Symbol(id)
>part.subparts[0].id : Symbol(id)
>part.subparts : Symbol(subparts)
>part : Symbol(part, Decl(conditionalTypes1.ts, 134, 13))
>subparts : Symbol(subparts)
>id : Symbol(id)

    part.updatePart("hello");  // Error
>part : Symbol(part, Decl(conditionalTypes1.ts, 134, 13))
}

type ZeroOf<T extends number | string | boolean> = T extends number ? 0 : T extends string ? "" : false;
>ZeroOf : Symbol(ZeroOf, Decl(conditionalTypes1.ts, 141, 1))
>T : Symbol(T, Decl(conditionalTypes1.ts, 143, 12))
>T : Symbol(T, Decl(conditionalTypes1.ts, 143, 12))
>T : Symbol(T, Decl(conditionalTypes1.ts, 143, 12))

function zeroOf<T extends number | string | boolean>(value: T) {
>zeroOf : Symbol(zeroOf, Decl(conditionalTypes1.ts, 143, 104))
>T : Symbol(T, Decl(conditionalTypes1.ts, 145, 16))
>value : Symbol(value, Decl(conditionalTypes1.ts, 145, 53))
>T : Symbol(T, Decl(conditionalTypes1.ts, 145, 16))

    return <ZeroOf<T>>(typeof value === "number" ? 0 : typeof value === "string" ? "" : false);
>ZeroOf : Symbol(ZeroOf, Decl(conditionalTypes1.ts, 141, 1))
>T : Symbol(T, Decl(conditionalTypes1.ts, 145, 16))
>value : Symbol(value, Decl(conditionalTypes1.ts, 145, 53))
>value : Symbol(value, Decl(conditionalTypes1.ts, 145, 53))
}

function f20<T extends string>(n: number, b: boolean, x: number | boolean, y: T) {
>f20 : Symbol(f20, Decl(conditionalTypes1.ts, 147, 1))
>T : Symbol(T, Decl(conditionalTypes1.ts, 149, 13))
>n : Symbol(n, Decl(conditionalTypes1.ts, 149, 31))
>b : Symbol(b, Decl(conditionalTypes1.ts, 149, 41))
>x : Symbol(x, Decl(conditionalTypes1.ts, 149, 53))
>y : Symbol(y, Decl(conditionalTypes1.ts, 149, 74))
>T : Symbol(T, Decl(conditionalTypes1.ts, 149, 13))

    zeroOf(5);  // 0
>zeroOf : Symbol(zeroOf, Decl(conditionalTypes1.ts, 143, 104))

    zeroOf("hello");  // ""
>zeroOf : Symbol(zeroOf, Decl(conditionalTypes1.ts, 143, 104))

    zeroOf(true);  // false
>zeroOf : Symbol(zeroOf, Decl(conditionalTypes1.ts, 143, 104))

    zeroOf(n);  // 0
>zeroOf : Symbol(zeroOf, Decl(conditionalTypes1.ts, 143, 104))
>n : Symbol(n, Decl(conditionalTypes1.ts, 149, 31))

    zeroOf(b);  // False
>zeroOf : Symbol(zeroOf, Decl(conditionalTypes1.ts, 143, 104))
>b : Symbol(b, Decl(conditionalTypes1.ts, 149, 41))

    zeroOf(x);  // 0 | false
>zeroOf : Symbol(zeroOf, Decl(conditionalTypes1.ts, 143, 104))
>x : Symbol(x, Decl(conditionalTypes1.ts, 149, 53))

    zeroOf(y);  // ZeroOf<T>
>zeroOf : Symbol(zeroOf, Decl(conditionalTypes1.ts, 143, 104))
>y : Symbol(y, Decl(conditionalTypes1.ts, 149, 74))
}

function f21<T extends number | string>(x: T, y: ZeroOf<T>) {
>f21 : Symbol(f21, Decl(conditionalTypes1.ts, 157, 1))
>T : Symbol(T, Decl(conditionalTypes1.ts, 159, 13))
>x : Symbol(x, Decl(conditionalTypes1.ts, 159, 40))
>T : Symbol(T, Decl(conditionalTypes1.ts, 159, 13))
>y : Symbol(y, Decl(conditionalTypes1.ts, 159, 45))
>ZeroOf : Symbol(ZeroOf, Decl(conditionalTypes1.ts, 141, 1))
>T : Symbol(T, Decl(conditionalTypes1.ts, 159, 13))

    let z1: number | string = y;
>z1 : Symbol(z1, Decl(conditionalTypes1.ts, 160, 7))
>y : Symbol(y, Decl(conditionalTypes1.ts, 159, 45))

    let z2: 0 | "" = y;
>z2 : Symbol(z2, Decl(conditionalTypes1.ts, 161, 7))
>y : Symbol(y, Decl(conditionalTypes1.ts, 159, 45))

    x = y;  // Error
>x : Symbol(x, Decl(conditionalTypes1.ts, 159, 40))
>y : Symbol(y, Decl(conditionalTypes1.ts, 159, 45))

    y = x;  // Error
>y : Symbol(y, Decl(conditionalTypes1.ts, 159, 45))
>x : Symbol(x, Decl(conditionalTypes1.ts, 159, 40))
}

type Extends<T, U> = T extends U ? true : false;
>Extends : Symbol(Extends, Decl(conditionalTypes1.ts, 164, 1))
>T : Symbol(T, Decl(conditionalTypes1.ts, 166, 13))
>U : Symbol(U, Decl(conditionalTypes1.ts, 166, 15))
>T : Symbol(T, Decl(conditionalTypes1.ts, 166, 13))
>U : Symbol(U, Decl(conditionalTypes1.ts, 166, 15))

type If<C extends boolean, T, F> = C extends true ? T : F;
>If : Symbol(If, Decl(conditionalTypes1.ts, 166, 48))
>C : Symbol(C, Decl(conditionalTypes1.ts, 167, 8))
>T : Symbol(T, Decl(conditionalTypes1.ts, 167, 26))
>F : Symbol(F, Decl(conditionalTypes1.ts, 167, 29))
>C : Symbol(C, Decl(conditionalTypes1.ts, 167, 8))
>T : Symbol(T, Decl(conditionalTypes1.ts, 167, 26))
>F : Symbol(F, Decl(conditionalTypes1.ts, 167, 29))

type Not<C extends boolean> = If<C, false, true>;
>Not : Symbol(Not, Decl(conditionalTypes1.ts, 167, 58))
>C : Symbol(C, Decl(conditionalTypes1.ts, 168, 9))
>If : Symbol(If, Decl(conditionalTypes1.ts, 166, 48))
>C : Symbol(C, Decl(conditionalTypes1.ts, 168, 9))

type And<A extends boolean, B extends boolean> = If<A, B, false>;
>And : Symbol(And, Decl(conditionalTypes1.ts, 168, 49))
>A : Symbol(A, Decl(conditionalTypes1.ts, 169, 9))
>B : Symbol(B, Decl(conditionalTypes1.ts, 169, 27))
>If : Symbol(If, Decl(conditionalTypes1.ts, 166, 48))
>A : Symbol(A, Decl(conditionalTypes1.ts, 169, 9))
>B : Symbol(B, Decl(conditionalTypes1.ts, 169, 27))

type Or<A extends boolean, B extends boolean> = If<A, true, B>;
>Or : Symbol(Or, Decl(conditionalTypes1.ts, 169, 65))
>A : Symbol(A, Decl(conditionalTypes1.ts, 170, 8))
>B : Symbol(B, Decl(conditionalTypes1.ts, 170, 26))
>If : Symbol(If, Decl(conditionalTypes1.ts, 166, 48))
>A : Symbol(A, Decl(conditionalTypes1.ts, 170, 8))
>B : Symbol(B, Decl(conditionalTypes1.ts, 170, 26))

type IsString<T> = Extends<T, string>;
>IsString : Symbol(IsString, Decl(conditionalTypes1.ts, 170, 63))
>T : Symbol(T, Decl(conditionalTypes1.ts, 172, 14))
>Extends : Symbol(Extends, Decl(conditionalTypes1.ts, 164, 1))
>T : Symbol(T, Decl(conditionalTypes1.ts, 172, 14))

type Q1 = IsString<number>;  // false
>Q1 : Symbol(Q1, Decl(conditionalTypes1.ts, 172, 38))
>IsString : Symbol(IsString, Decl(conditionalTypes1.ts, 170, 63))

type Q2 = IsString<"abc">;  // true
>Q2 : Symbol(Q2, Decl(conditionalTypes1.ts, 174, 27))
>IsString : Symbol(IsString, Decl(conditionalTypes1.ts, 170, 63))

type Q3 = IsString<any>;  // boolean
>Q3 : Symbol(Q3, Decl(conditionalTypes1.ts, 175, 26))
>IsString : Symbol(IsString, Decl(conditionalTypes1.ts, 170, 63))

type Q4 = IsString<never>;  // boolean
>Q4 : Symbol(Q4, Decl(conditionalTypes1.ts, 176, 24))
>IsString : Symbol(IsString, Decl(conditionalTypes1.ts, 170, 63))

type N1 = Not<false>;  // true
>N1 : Symbol(N1, Decl(conditionalTypes1.ts, 177, 26))
>Not : Symbol(Not, Decl(conditionalTypes1.ts, 167, 58))

type N2 = Not<true>;  // false
>N2 : Symbol(N2, Decl(conditionalTypes1.ts, 179, 21))
>Not : Symbol(Not, Decl(conditionalTypes1.ts, 167, 58))

type N3 = Not<boolean>;  // boolean
>N3 : Symbol(N3, Decl(conditionalTypes1.ts, 180, 20))
>Not : Symbol(Not, Decl(conditionalTypes1.ts, 167, 58))

type A1 = And<false, false>;  // false
>A1 : Symbol(A1, Decl(conditionalTypes1.ts, 181, 23))
>And : Symbol(And, Decl(conditionalTypes1.ts, 168, 49))

type A2 = And<false, true>;  // false
>A2 : Symbol(A2, Decl(conditionalTypes1.ts, 183, 28))
>And : Symbol(And, Decl(conditionalTypes1.ts, 168, 49))

type A3 = And<true, false>;  // false
>A3 : Symbol(A3, Decl(conditionalTypes1.ts, 184, 27))
>And : Symbol(And, Decl(conditionalTypes1.ts, 168, 49))

type A4 = And<true, true>;  // true
>A4 : Symbol(A4, Decl(conditionalTypes1.ts, 185, 27))
>And : Symbol(And, Decl(conditionalTypes1.ts, 168, 49))

type A5 = And<boolean, false>;  // false
>A5 : Symbol(A5, Decl(conditionalTypes1.ts, 186, 26))
>And : Symbol(And, Decl(conditionalTypes1.ts, 168, 49))

type A6 = And<false, boolean>;  // false
>A6 : Symbol(A6, Decl(conditionalTypes1.ts, 187, 30))
>And : Symbol(And, Decl(conditionalTypes1.ts, 168, 49))

type A7 = And<boolean, true>;  // boolean
>A7 : Symbol(A7, Decl(conditionalTypes1.ts, 188, 30))
>And : Symbol(And, Decl(conditionalTypes1.ts, 168, 49))

type A8 = And<true, boolean>;  // boolean
>A8 : Symbol(A8, Decl(conditionalTypes1.ts, 189, 29))
>And : Symbol(And, Decl(conditionalTypes1.ts, 168, 49))

type A9 = And<boolean, boolean>;  // boolean
>A9 : Symbol(A9, Decl(conditionalTypes1.ts, 190, 29))
>And : Symbol(And, Decl(conditionalTypes1.ts, 168, 49))

type O1 = Or<false, false>;  // false
>O1 : Symbol(O1, Decl(conditionalTypes1.ts, 191, 32))
>Or : Symbol(Or, Decl(conditionalTypes1.ts, 169, 65))

type O2 = Or<false, true>;  // true
>O2 : Symbol(O2, Decl(conditionalTypes1.ts, 193, 27))
>Or : Symbol(Or, Decl(conditionalTypes1.ts, 169, 65))

type O3 = Or<true, false>;  // true
>O3 : Symbol(O3, Decl(conditionalTypes1.ts, 194, 26))
>Or : Symbol(Or, Decl(conditionalTypes1.ts, 169, 65))

type O4 = Or<true, true>;  // true
>O4 : Symbol(O4, Decl(conditionalTypes1.ts, 195, 26))
>Or : Symbol(Or, Decl(conditionalTypes1.ts, 169, 65))

type O5 = Or<boolean, false>;  // boolean
>O5 : Symbol(O5, Decl(conditionalTypes1.ts, 196, 25))
>Or : Symbol(Or, Decl(conditionalTypes1.ts, 169, 65))

type O6 = Or<false, boolean>;  // boolean
>O6 : Symbol(O6, Decl(conditionalTypes1.ts, 197, 29))
>Or : Symbol(Or, Decl(conditionalTypes1.ts, 169, 65))

type O7 = Or<boolean, true>;  // true
>O7 : Symbol(O7, Decl(conditionalTypes1.ts, 198, 29))
>Or : Symbol(Or, Decl(conditionalTypes1.ts, 169, 65))

type O8 = Or<true, boolean>;  // true
>O8 : Symbol(O8, Decl(conditionalTypes1.ts, 199, 28))
>Or : Symbol(Or, Decl(conditionalTypes1.ts, 169, 65))

type O9 = Or<boolean, boolean>;  // boolean
>O9 : Symbol(O9, Decl(conditionalTypes1.ts, 200, 28))
>Or : Symbol(Or, Decl(conditionalTypes1.ts, 169, 65))

type T40 = never extends never ? true : false;  // true
>T40 : Symbol(T40, Decl(conditionalTypes1.ts, 201, 31))

type T41 = number extends never ? true : false;  // false
>T41 : Symbol(T41, Decl(conditionalTypes1.ts, 203, 46))

type T42 = never extends number ? true : false;  // boolean
>T42 : Symbol(T42, Decl(conditionalTypes1.ts, 204, 47))

type IsNever<T> = T extends never ? true : false;
>IsNever : Symbol(IsNever, Decl(conditionalTypes1.ts, 205, 47))
>T : Symbol(T, Decl(conditionalTypes1.ts, 207, 13))
>T : Symbol(T, Decl(conditionalTypes1.ts, 207, 13))

type T50 = IsNever<never>;  // true
>T50 : Symbol(T50, Decl(conditionalTypes1.ts, 207, 49))
>IsNever : Symbol(IsNever, Decl(conditionalTypes1.ts, 205, 47))

type T51 = IsNever<number>;  // false
>T51 : Symbol(T51, Decl(conditionalTypes1.ts, 209, 26))
>IsNever : Symbol(IsNever, Decl(conditionalTypes1.ts, 205, 47))

type T52 = IsNever<any>;  // false
>T52 : Symbol(T52, Decl(conditionalTypes1.ts, 210, 27))
>IsNever : Symbol(IsNever, Decl(conditionalTypes1.ts, 205, 47))

// Repros from #21664

type Eq<T, U> = T extends U ? U extends T ? true : false : false;
>Eq : Symbol(Eq, Decl(conditionalTypes1.ts, 211, 24))
>T : Symbol(T, Decl(conditionalTypes1.ts, 215, 8))
>U : Symbol(U, Decl(conditionalTypes1.ts, 215, 10))
>T : Symbol(T, Decl(conditionalTypes1.ts, 215, 8))
>U : Symbol(U, Decl(conditionalTypes1.ts, 215, 10))
>U : Symbol(U, Decl(conditionalTypes1.ts, 215, 10))
>T : Symbol(T, Decl(conditionalTypes1.ts, 215, 8))

type T60 = Eq<true, true>;  // true
>T60 : Symbol(T60, Decl(conditionalTypes1.ts, 215, 65))
>Eq : Symbol(Eq, Decl(conditionalTypes1.ts, 211, 24))

type T61 = Eq<true, false>;  // false
>T61 : Symbol(T61, Decl(conditionalTypes1.ts, 216, 26))
>Eq : Symbol(Eq, Decl(conditionalTypes1.ts, 211, 24))

type T62 = Eq<false, true>;  // false
>T62 : Symbol(T62, Decl(conditionalTypes1.ts, 217, 27))
>Eq : Symbol(Eq, Decl(conditionalTypes1.ts, 211, 24))

type T63 = Eq<false, false>;  // true
>T63 : Symbol(T63, Decl(conditionalTypes1.ts, 218, 27))
>Eq : Symbol(Eq, Decl(conditionalTypes1.ts, 211, 24))

type Eq1<T, U> = Eq<T, U> extends false ? false : true;
>Eq1 : Symbol(Eq1, Decl(conditionalTypes1.ts, 219, 28))
>T : Symbol(T, Decl(conditionalTypes1.ts, 221, 9))
>U : Symbol(U, Decl(conditionalTypes1.ts, 221, 11))
>Eq : Symbol(Eq, Decl(conditionalTypes1.ts, 211, 24))
>T : Symbol(T, Decl(conditionalTypes1.ts, 221, 9))
>U : Symbol(U, Decl(conditionalTypes1.ts, 221, 11))

type T70 = Eq1<true, true>;  // true
>T70 : Symbol(T70, Decl(conditionalTypes1.ts, 221, 55))
>Eq1 : Symbol(Eq1, Decl(conditionalTypes1.ts, 219, 28))

type T71 = Eq1<true, false>;  // false
>T71 : Symbol(T71, Decl(conditionalTypes1.ts, 222, 27))
>Eq1 : Symbol(Eq1, Decl(conditionalTypes1.ts, 219, 28))

type T72 = Eq1<false, true>;  // false
>T72 : Symbol(T72, Decl(conditionalTypes1.ts, 223, 28))
>Eq1 : Symbol(Eq1, Decl(conditionalTypes1.ts, 219, 28))

type T73 = Eq1<false, false>;  // true
>T73 : Symbol(T73, Decl(conditionalTypes1.ts, 224, 28))
>Eq1 : Symbol(Eq1, Decl(conditionalTypes1.ts, 219, 28))

type Eq2<T, U> = Eq<T, U> extends true ? true : false;
>Eq2 : Symbol(Eq2, Decl(conditionalTypes1.ts, 225, 29))
>T : Symbol(T, Decl(conditionalTypes1.ts, 227, 9))
>U : Symbol(U, Decl(conditionalTypes1.ts, 227, 11))
>Eq : Symbol(Eq, Decl(conditionalTypes1.ts, 211, 24))
>T : Symbol(T, Decl(conditionalTypes1.ts, 227, 9))
>U : Symbol(U, Decl(conditionalTypes1.ts, 227, 11))

type T80 = Eq2<true, true>;  // true
>T80 : Symbol(T80, Decl(conditionalTypes1.ts, 227, 54))
>Eq2 : Symbol(Eq2, Decl(conditionalTypes1.ts, 225, 29))

type T81 = Eq2<true, false>;  // false
>T81 : Symbol(T81, Decl(conditionalTypes1.ts, 228, 27))
>Eq2 : Symbol(Eq2, Decl(conditionalTypes1.ts, 225, 29))

type T82 = Eq2<false, true>;  // false
>T82 : Symbol(T82, Decl(conditionalTypes1.ts, 229, 28))
>Eq2 : Symbol(Eq2, Decl(conditionalTypes1.ts, 225, 29))

type T83 = Eq2<false, false>;  // true
>T83 : Symbol(T83, Decl(conditionalTypes1.ts, 230, 28))
>Eq2 : Symbol(Eq2, Decl(conditionalTypes1.ts, 225, 29))

// Repro from #21756

type Foo<T> = T extends string ? boolean : number;
>Foo : Symbol(Foo, Decl(conditionalTypes1.ts, 231, 29))
>T : Symbol(T, Decl(conditionalTypes1.ts, 235, 9))
>T : Symbol(T, Decl(conditionalTypes1.ts, 235, 9))

type Bar<T> = T extends string ? boolean : number;
>Bar : Symbol(Bar, Decl(conditionalTypes1.ts, 235, 50))
>T : Symbol(T, Decl(conditionalTypes1.ts, 236, 9))
>T : Symbol(T, Decl(conditionalTypes1.ts, 236, 9))

const convert = <U>(value: Foo<U>): Bar<U> => value;
>convert : Symbol(convert, Decl(conditionalTypes1.ts, 237, 5))
>U : Symbol(U, Decl(conditionalTypes1.ts, 237, 17))
>value : Symbol(value, Decl(conditionalTypes1.ts, 237, 20))
>Foo : Symbol(Foo, Decl(conditionalTypes1.ts, 231, 29))
>U : Symbol(U, Decl(conditionalTypes1.ts, 237, 17))
>Bar : Symbol(Bar, Decl(conditionalTypes1.ts, 235, 50))
>U : Symbol(U, Decl(conditionalTypes1.ts, 237, 17))
>value : Symbol(value, Decl(conditionalTypes1.ts, 237, 20))

type Baz<T> = Foo<T>;
>Baz : Symbol(Baz, Decl(conditionalTypes1.ts, 237, 52))
>T : Symbol(T, Decl(conditionalTypes1.ts, 239, 9))
>Foo : Symbol(Foo, Decl(conditionalTypes1.ts, 231, 29))
>T : Symbol(T, Decl(conditionalTypes1.ts, 239, 9))

const convert2 = <T>(value: Foo<T>): Baz<T> => value;
>convert2 : Symbol(convert2, Decl(conditionalTypes1.ts, 240, 5))
>T : Symbol(T, Decl(conditionalTypes1.ts, 240, 18))
>value : Symbol(value, Decl(conditionalTypes1.ts, 240, 21))
>Foo : Symbol(Foo, Decl(conditionalTypes1.ts, 231, 29))
>T : Symbol(T, Decl(conditionalTypes1.ts, 240, 18))
>Baz : Symbol(Baz, Decl(conditionalTypes1.ts, 237, 52))
>T : Symbol(T, Decl(conditionalTypes1.ts, 240, 18))
>value : Symbol(value, Decl(conditionalTypes1.ts, 240, 21))

function f31<T>() {
>f31 : Symbol(f31, Decl(conditionalTypes1.ts, 240, 53))
>T : Symbol(T, Decl(conditionalTypes1.ts, 242, 13))

    type T1 = T extends string ? boolean : number;
>T1 : Symbol(T1, Decl(conditionalTypes1.ts, 242, 19))
>T : Symbol(T, Decl(conditionalTypes1.ts, 242, 13))

    type T2 = T extends string ? boolean : number;
>T2 : Symbol(T2, Decl(conditionalTypes1.ts, 243, 50))
>T : Symbol(T, Decl(conditionalTypes1.ts, 242, 13))

    var x: T1;
>x : Symbol(x, Decl(conditionalTypes1.ts, 245, 7), Decl(conditionalTypes1.ts, 246, 7))
>T1 : Symbol(T1, Decl(conditionalTypes1.ts, 242, 19))

    var x: T2;
>x : Symbol(x, Decl(conditionalTypes1.ts, 245, 7), Decl(conditionalTypes1.ts, 246, 7))
>T2 : Symbol(T2, Decl(conditionalTypes1.ts, 243, 50))
}

function f32<T, U>() {
>f32 : Symbol(f32, Decl(conditionalTypes1.ts, 247, 1))
>T : Symbol(T, Decl(conditionalTypes1.ts, 249, 13))
>U : Symbol(U, Decl(conditionalTypes1.ts, 249, 15))

    type T1 = T & U extends string ? boolean : number;
>T1 : Symbol(T1, Decl(conditionalTypes1.ts, 249, 22))
>T : Symbol(T, Decl(conditionalTypes1.ts, 249, 13))
>U : Symbol(U, Decl(conditionalTypes1.ts, 249, 15))

    type T2 = Foo<T & U>;
>T2 : Symbol(T2, Decl(conditionalTypes1.ts, 250, 54))
>Foo : Symbol(Foo, Decl(conditionalTypes1.ts, 231, 29))
>T : Symbol(T, Decl(conditionalTypes1.ts, 249, 13))
>U : Symbol(U, Decl(conditionalTypes1.ts, 249, 15))

    var z: T1;
>z : Symbol(z, Decl(conditionalTypes1.ts, 252, 7), Decl(conditionalTypes1.ts, 253, 7))
>T1 : Symbol(T1, Decl(conditionalTypes1.ts, 249, 22))

    var z: T2;  // Error, T2 is distributive, T1 isn't
>z : Symbol(z, Decl(conditionalTypes1.ts, 252, 7), Decl(conditionalTypes1.ts, 253, 7))
>T2 : Symbol(T2, Decl(conditionalTypes1.ts, 250, 54))
}

function f33<T, U>() {
>f33 : Symbol(f33, Decl(conditionalTypes1.ts, 254, 1))
>T : Symbol(T, Decl(conditionalTypes1.ts, 256, 13))
>U : Symbol(U, Decl(conditionalTypes1.ts, 256, 15))

    type T1 = Foo<T & U>;
>T1 : Symbol(T1, Decl(conditionalTypes1.ts, 256, 22))
>Foo : Symbol(Foo, Decl(conditionalTypes1.ts, 231, 29))
>T : Symbol(T, Decl(conditionalTypes1.ts, 256, 13))
>U : Symbol(U, Decl(conditionalTypes1.ts, 256, 15))

    type T2 = Bar<T & U>;
>T2 : Symbol(T2, Decl(conditionalTypes1.ts, 257, 25))
>Bar : Symbol(Bar, Decl(conditionalTypes1.ts, 235, 50))
>T : Symbol(T, Decl(conditionalTypes1.ts, 256, 13))
>U : Symbol(U, Decl(conditionalTypes1.ts, 256, 15))

    var z: T1;
>z : Symbol(z, Decl(conditionalTypes1.ts, 259, 7), Decl(conditionalTypes1.ts, 260, 7))
>T1 : Symbol(T1, Decl(conditionalTypes1.ts, 256, 22))

    var z: T2;
>z : Symbol(z, Decl(conditionalTypes1.ts, 259, 7), Decl(conditionalTypes1.ts, 260, 7))
>T2 : Symbol(T2, Decl(conditionalTypes1.ts, 257, 25))
}

// Repro from #21823

type T90<T> = T extends 0 ? 0 : () => 0;
>T90 : Symbol(T90, Decl(conditionalTypes1.ts, 261, 1))
>T : Symbol(T, Decl(conditionalTypes1.ts, 265, 9))
>T : Symbol(T, Decl(conditionalTypes1.ts, 265, 9))

type T91<T> = T extends 0 ? 0 : () => 0;
>T91 : Symbol(T91, Decl(conditionalTypes1.ts, 265, 40))
>T : Symbol(T, Decl(conditionalTypes1.ts, 266, 9))
>T : Symbol(T, Decl(conditionalTypes1.ts, 266, 9))

const f40 = <U>(a: T90<U>): T91<U> => a;
>f40 : Symbol(f40, Decl(conditionalTypes1.ts, 267, 5))
>U : Symbol(U, Decl(conditionalTypes1.ts, 267, 13))
>a : Symbol(a, Decl(conditionalTypes1.ts, 267, 16))
>T90 : Symbol(T90, Decl(conditionalTypes1.ts, 261, 1))
>U : Symbol(U, Decl(conditionalTypes1.ts, 267, 13))
>T91 : Symbol(T91, Decl(conditionalTypes1.ts, 265, 40))
>U : Symbol(U, Decl(conditionalTypes1.ts, 267, 13))
>a : Symbol(a, Decl(conditionalTypes1.ts, 267, 16))

const f41 = <U>(a: T91<U>): T90<U> => a;
>f41 : Symbol(f41, Decl(conditionalTypes1.ts, 268, 5))
>U : Symbol(U, Decl(conditionalTypes1.ts, 268, 13))
>a : Symbol(a, Decl(conditionalTypes1.ts, 268, 16))
>T91 : Symbol(T91, Decl(conditionalTypes1.ts, 265, 40))
>U : Symbol(U, Decl(conditionalTypes1.ts, 268, 13))
>T90 : Symbol(T90, Decl(conditionalTypes1.ts, 261, 1))
>U : Symbol(U, Decl(conditionalTypes1.ts, 268, 13))
>a : Symbol(a, Decl(conditionalTypes1.ts, 268, 16))

type T92<T> = T extends () => 0 ? () => 1 : () => 2;
>T92 : Symbol(T92, Decl(conditionalTypes1.ts, 268, 40))
>T : Symbol(T, Decl(conditionalTypes1.ts, 270, 9))
>T : Symbol(T, Decl(conditionalTypes1.ts, 270, 9))

type T93<T> = T extends () => 0 ? () => 1 : () => 2;
>T93 : Symbol(T93, Decl(conditionalTypes1.ts, 270, 52))
>T : Symbol(T, Decl(conditionalTypes1.ts, 271, 9))
>T : Symbol(T, Decl(conditionalTypes1.ts, 271, 9))

const f42 = <U>(a: T92<U>): T93<U> => a;
>f42 : Symbol(f42, Decl(conditionalTypes1.ts, 272, 5))
>U : Symbol(U, Decl(conditionalTypes1.ts, 272, 13))
>a : Symbol(a, Decl(conditionalTypes1.ts, 272, 16))
>T92 : Symbol(T92, Decl(conditionalTypes1.ts, 268, 40))
>U : Symbol(U, Decl(conditionalTypes1.ts, 272, 13))
>T93 : Symbol(T93, Decl(conditionalTypes1.ts, 270, 52))
>U : Symbol(U, Decl(conditionalTypes1.ts, 272, 13))
>a : Symbol(a, Decl(conditionalTypes1.ts, 272, 16))

const f43 = <U>(a: T93<U>): T92<U> => a;
>f43 : Symbol(f43, Decl(conditionalTypes1.ts, 273, 5))
>U : Symbol(U, Decl(conditionalTypes1.ts, 273, 13))
>a : Symbol(a, Decl(conditionalTypes1.ts, 273, 16))
>T93 : Symbol(T93, Decl(conditionalTypes1.ts, 270, 52))
>U : Symbol(U, Decl(conditionalTypes1.ts, 273, 13))
>T92 : Symbol(T92, Decl(conditionalTypes1.ts, 268, 40))
>U : Symbol(U, Decl(conditionalTypes1.ts, 273, 13))
>a : Symbol(a, Decl(conditionalTypes1.ts, 273, 16))

type T94<T> = T extends string ? true : 42;
>T94 : Symbol(T94, Decl(conditionalTypes1.ts, 273, 40))
>T : Symbol(T, Decl(conditionalTypes1.ts, 275, 9))
>T : Symbol(T, Decl(conditionalTypes1.ts, 275, 9))

type T95<T> = T extends string ? boolean : number;
>T95 : Symbol(T95, Decl(conditionalTypes1.ts, 275, 43))
>T : Symbol(T, Decl(conditionalTypes1.ts, 276, 9))
>T : Symbol(T, Decl(conditionalTypes1.ts, 276, 9))

const f44 = <U>(value: T94<U>): T95<U> => value;
>f44 : Symbol(f44, Decl(conditionalTypes1.ts, 277, 5))
>U : Symbol(U, Decl(conditionalTypes1.ts, 277, 13))
>value : Symbol(value, Decl(conditionalTypes1.ts, 277, 16))
>T94 : Symbol(T94, Decl(conditionalTypes1.ts, 273, 40))
>U : Symbol(U, Decl(conditionalTypes1.ts, 277, 13))
>T95 : Symbol(T95, Decl(conditionalTypes1.ts, 275, 43))
>U : Symbol(U, Decl(conditionalTypes1.ts, 277, 13))
>value : Symbol(value, Decl(conditionalTypes1.ts, 277, 16))

const f45 = <U>(value: T95<U>): T94<U> => value;  // Error
>f45 : Symbol(f45, Decl(conditionalTypes1.ts, 278, 5))
>U : Symbol(U, Decl(conditionalTypes1.ts, 278, 13))
>value : Symbol(value, Decl(conditionalTypes1.ts, 278, 16))
>T95 : Symbol(T95, Decl(conditionalTypes1.ts, 275, 43))
>U : Symbol(U, Decl(conditionalTypes1.ts, 278, 13))
>T94 : Symbol(T94, Decl(conditionalTypes1.ts, 273, 40))
>U : Symbol(U, Decl(conditionalTypes1.ts, 278, 13))
>value : Symbol(value, Decl(conditionalTypes1.ts, 278, 16))

